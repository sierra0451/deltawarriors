enum TP_RESULT
{
	TP_FAIL = 0,
	TP_USE = 1,
	TP_INFINITE = 2
}

enum DELTA_PSP
{
	PSP_LEGS = -10,
	PSP_OFFHAND = -5
}

class DeltaPlayer : PlayerPawn abstract
{
	double tensionPoints;
	double maxTensionPoints;
	int ticLastGrazed;
	int tensionDrainTimer;
	bool beingHugged;
	int hugReactionTime;
	Actor lungeTarget;
	
	protected int airTimer; 						// when alive, used to coyote time. when dead, used to determine if we made a thud sound upon corpse landing
	protected int jumpBuffer, airBobTics, hugTimer;
	protected int damageTics; 						// invulnerability frames, essentially
	protected int deathTimer; 						// used for first person death animation
	protected Color characterColor, overhealColor;
	protected double deathPitchFP, deathPitchTP;
	
	protected float flinchMultiplier;
	protected int startFlinchTics;
	
	protected bool lunging;
	protected float lungeSpeed;
	protected float lungeStopDistance;
	protected Array<Actor> grazed;
	
	protected bool isUsingOffhand;
	protected string offhandIcon;
	
	protected LinearValueInterpolator heartbeat;
	
	private float _targetRoll;
	private bool _frozenDeath;						// using this for custom ice death that doesn't automatically shatter us lol
	
	// used for weapon flinching when taking damage
	private Vector2 _currentFlinch;
	private int _flinchTics;
	private TextureID _offhandIconId;
	
	// Damage types that ignore I-frames and Kris's shield.
	static const Name DAMAGE_TYPES_IGNORE_IFRAMES[] =
	{
		'Crush',
		'Telefrag',
		'Falling',
		'Suicide',
		'Exit',
		'Poison'
	};
	const MAX_AIR_BOB_TICS = 5;
	const DAMAGE_IFRAMES = 10;
	const DRAIN_TIMER_START = TICRATE * 12;			// tp lasts for 12 seconds before we start draining it
	
	property HugReactionTime: hugReactionTime;
	property CharacterColor: characterColor;		// mostly used for hud elements
	property OverhealColor: overhealColor;			// used for overheal bar on hud
	property FlinchMultiplier: flinchMultiplier;
	property StartFlinchTics: startFlinchTics;
	property LungeSpeed: lungeSpeed;
	property OffhandIcon: offhandIcon;
	
	Default
	{
		Height 36;
		Radius 16;
		Speed 0.7;
		Mass 100;
		PainChance 256;
		
		Health 100;
		Player.MaxHealth 100;
		
		Player.MugShotMaxHealth -1;
		
		Player.DisplayName "DeltaPlayer";
		Player.SoundClass "delta";
		Player.ViewHeight 32.0;
		
		// strafing should be same speed as moving forward
		Player.ForwardMove 1, 1;
		Player.SideMove 1.25, 1.25;
		
		Player.AttackZOffset 12;
		Player.JumpZ 12;
		Player.GruntSpeed 3;
		Player.ViewBob 0.2;
		Player.ViewBobSpeed 12;
		Player.FlyBob 0;
		Player.InvulnerabilityMode "Reflective";
		
		DeltaPlayer.HugReactionTime 20;
		DeltaPlayer.CharacterColor Color(127, 127, 127);
		DeltaPlayer.OverhealColor Color(60, 220, 60);
		DeltaPlayer.FlinchMultiplier 10;
		DeltaPlayer.StartFlinchTics 5;
		DeltaPlayer.LungeSpeed 35;
		
		+PLAYERPAWN.MAKEFOOTSTEPS
		+DONTGIB					// prevents us from being turned into a pile of flattened meat by crushers
		+NOICEDEATH
	}
	
	override void BeginPlay()
	{
		Super.BeginPlay();
		_offhandIconId = TexMan.CheckForTexture(offhandIcon); // load texture before we do the rest of our initialization
	}
	
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		
		airTimer = 0;
		jumpBuffer = 0;
		ticLastGrazed = -1;
		hugTimer = 0;
		deathTimer = -1;
		tensionPoints = 0;
		maxTensionPoints = 250;
		tensionDrainTimer = 0;
		airBobTics = 0;
		beingHugged = false;
		lunging = false;
		isUsingOffhand = false;
		
		_targetRoll = 0;
	}
	
	override void Travelled()
	{
		Super.Travelled();
		
		airTimer = 0;
		jumpBuffer = 0;
		ticLastGrazed = -1;
		hugTimer = 0;
		tensionPoints = 0;
		tensionDrainTimer = 0;
		airBobTics = 0;
		beingHugged = false;
		lunging = false;
		isUsingOffhand = false;
		
		_targetRoll = 0;
		Vel = (0, 0, 0);
	}
	
	override void PlayerThink()
	{
		Super.PlayerThink();
		
		HandleHeartbeat();
		HandleViewRoll();
		
		if (player.PlayerState == PST_DEAD)
		{
			deathTimer++;
			return;
		}
		
		HandleLunging();
		HandleIFrames();
		DrainTension();
		HandleRalseiHugs();
		HandleAirStuff();
		HandleFlinch();
		CheckGraze();
	}

	override void ApplyAirControl(out double movefactor, out double bobfactor)
	{
		movefactor *= level.aircontrol;
		bobfactor *= level.aircontrol;
	}
	
	// grabbing code from uzdoom.pk3 and retooling for more preferred feeling
	override void MovePlayer()
	{
		if (!player)
			return;
		
		UserCmd cmd = player.cmd;
		bool doingMoveInput = player.buttons & (BT_MOVERIGHT | BT_MOVELEFT | BT_BACK | BT_FORWARD);
		
		// [RH] 180-degree turn overrides all other yaws
		if (player.turnticks && !lunging)
		{
			player.turnticks--;
			A_SetAngle(Angle + (180. / TURN180_TICKS), SPF_INTERPOLATE);
		}
		else if (!lunging)
			Angle += cmd.yaw * (360./65536.);

		player.onground = (pos.z <= floorz) || bOnMobj || bMBFBouncer || (player.cheats & CF_NOCLIP2);

		// killough 10/98:
		//
		// We must apply thrust to the player and bobbing separately, to avoid
		// anomalies. The thrust applied to bobbing is always the same strength on
		// ice, because the player still "works just as hard" to move, while the
		// thrust applied to the movement varies with 'movefactor'.

		//if (cmd.forwardmove | cmd.sidemove)
		{
			double forwardmove, sidemove;
			double bobfactor;
			double friction, movefactor;
			double fm, sm;
			double perc = 1 - airBobTics / float(MAX_AIR_BOB_TICS);

			[friction, movefactor] = GetFriction();
			bobfactor = friction < ORIG_FRICTION ? movefactor : ORIG_FRICTION_FACTOR;
			bobfactor *= perc;
			
			fm = cmd.forwardmove;
			sm = cmd.sidemove;
			[fm, sm] = TweakSpeeds (fm, sm);
			fm *= Speed / 256;
			sm *= Speed / 256;
			
			if (!player.onground && !bNoGravity && !waterlevel)
			{
				// [RH] allow very limited movement if not on ground.
				// [AA] but also allow authors to override it.
				ApplyAirControl(movefactor, bobfactor);
			}

			// When crouching, speed and bobbing have to be reduced
			if (CanCrouch() && player.crouchfactor != 1)
			{
				fm *= player.crouchfactor;
				sm *= player.crouchfactor;
				bobfactor *= player.crouchfactor;
			}
			
			forwardmove = fm * movefactor * (35 / TICRATE);
			sidemove = sm * movefactor * (35 / TICRATE);
			
			if (lunging)
				player.vel = (0, 0);
			else
			{
				if (forwardmove)
				{
					Bob(Angle, cmd.forwardmove * bobfactor / 256., true);
					ForwardThrust(forwardmove, Angle);
				}
				if (sidemove)
				{
					let a = Angle - 90;
					Bob(a, cmd.sidemove * bobfactor / 256., false);
					Thrust(sidemove, a);
				}
			}
			
			if (player.cheats & CF_REVERTPLEASE)
			{
				player.cheats &= ~CF_REVERTPLEASE;
				player.camera = player.mo;
			}
		}
			
		if (!IsPredicting())
		{
			if (doingMoveInput && Vel.LengthSquared() > 0)
				PlayRunning();
			else
				PlayIdle();
		}
	}
	
	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		bool ignoreIFrames = false;
		
		foreach (damageType : DAMAGE_TYPES_IGNORE_IFRAMES)
		{
			if (mod == damageType)
			{
				ignoreIFrames = true;
				break;
			}
		}
		
		if (_frozenDeath && mod != "Ice")
		{
			Vel = (0, 0, 0);
			A_FreezeDeathChunks();
		}	
		
		if (damageTics > 0 && !ignoreIFrames)
			return 0;
		
		int finalDamage = Super.DamageMobj(inflictor, source, damage, mod, flags, angle);
		
		if (finalDamage > 0 && Health > 0)
		{
			A_StartSound("delta/hurt", CHAN_VOICE, 0, 1, 0.5);
			if (!ignoreIFrames)
				damageTics = (inflictor && inflictor.bIsPuff) ? -1 : DAMAGE_IFRAMES;
			if (mod == 'Falling')
				A_StartSound("delta/fall_damage", CHAN_AUTO);
			
			if (source && source != self)
			{
				float ang = DeltaAngle(self.angle, AngleTo(inflictor)) + cfrandom(-15, 15);
				DamageFlinch(ang);
			}
		}
		
		if (player && player.damageCount > 25)
			player.damageCount = 25;
		
		return finalDamage;
	}
	
	override void Die(Actor source, Actor inflictor, int dmgFlags, Name MeansOfDeath)
	{
		Super.Die(source, inflictor, dmgFlags, MeansOfDeath);
		
		if (lunging)
		{
			let oldVel = Vel;
			StopLunge();
			Vel = oldVel;
		}
		
		deathTimer = 0;
		deathPitchFP = deathPitchTP = Pitch;
	}
	
	// taking implementation from uzdoom.pk3, slightly retooling for different look on death
	override void DeathThink()
	{
		if (!player)
			return;
		
		player.Uncrouch();
		player.onground = (pos.Z <= floorz);
		
		if (!_frozenDeath && player.onGround)
		{
			// Fall to ground (if not frozen)
			player.deltaviewheight = 0;
			if (player.viewheight > 6)
				player.viewheight -= deathTimer;
				
			if (player.viewheight < 6)
				player.viewheight = 6;
			
			if (player.viewHeight == 6)
			{
				if (deathPitchFP > -19.)
				{
					double lookDelta = (-19. - deathPitchFP) / 8;
					deathPitchFP += lookDelta;
				}
				
				if (abs(deathPitchTP) > 0.01)
				{
					double lookDelta = -deathPitchTP / 8;
					deathPitchTP += lookDelta;
				}
				else if (!(deathPitchTP ~== 0))
					deathPitchTP = 0;
				
				if (!(player.cheats & CF_CHASECAM))
					Pitch = deathPitchFP;
				else
					Pitch = deathPitchTP;
			}
		}
		
		player.mo.CalcHeight ();
		
		if (player.damagecount)
			player.damagecount--;
		
		if (player.poisoncount)
			player.poisoncount--;
		
		if ((player.cmd.buttons & BT_USE ||
			((deathmatch || alwaysapplydmflags) && sv_forcerespawn)) && !sv_norespawn)
		{
			if (Level.maptime >= player.respawn_time || ((player.cmd.buttons & BT_USE) && player.Bot == NULL))
			{
				player.cls = NULL;		// Force a new class if the player is using a random class
				player.playerstate = (multiplayer || level.AllowRespawn || sv_singleplayerrespawn || G_SkillPropertyInt(SKILLP_PlayerRespawn)) ? PST_REBORN : PST_ENTER;
				if (special1 > 2)
				{
					special1 = 0;
				}
			}
		}
	}
	
	// Grabbing GZDoom's player code and retooling it to work with coyote time and jump buffering
	override void CheckJump()
	{
		if (!player)
			return;
		
		// Buffer jump inputs
		if (player.cmd.buttons & BT_JUMP)
			jumpBuffer = 3;
		
		// [RH] check for jump
		if (jumpBuffer > 0)
		{
			jumpBuffer--;
			
			if (waterlevel >= 2)
			{
				Vel.Z = 4 * Speed;
			}
			else if (bNoGravity)
			{
				Vel.Z = 3.;
			}
			// airTimer < 4 instead of grounded check, allows for coyote time
			else if (level.IsJumpingAllowed() && airTimer < 4 && Vel.Z <= 0)
			{
				if (GetCrouching())
					player.crouchOffset = 0;
				
				double jumpvelz = JumpZ * 35 / TICRATE;
				double jumpfac = 0;
				
				// [BC] If the player has the high jump power, double their jump velocity.
				// (actually, pick the best factors from all active items.)
				for (let p = Inv; p != null; p = p.Inv)
				{
					let pp = PowerHighJump(p);
					if (pp)
					{
						double f = pp.Strength;
						if (f > jumpfac) jumpfac = f;
					}
				}
				if (jumpfac > 0) jumpvelz *= jumpfac;
				
				Vel.Z = jumpvelz;
				bOnMobj = false;
				jumpBuffer = 0;
				
				if (!IsPredicting())
					A_StartSound("*jump", CHAN_BODY);
			}
		}
	}
	
	override void CheckCrouch(bool totallyFrozen)
	{
		if (!player)
			return;
		
		int buttons = player.cmd.buttons;
		
		if (CanCrouch() && player.health > 0 && level.IsCrouchingAllowed())
		{
			if (!totallyfrozen)
			{
				int crouchdir = player.crouching;
				
				if (crouchdir == 0)
					crouchdir = (player.cmd.buttons & BT_CROUCH) ? -1 : 1;
				else if (player.cmd.buttons & BT_CROUCH)
					player.crouching = 0;
				
				if (crouchdir == 1 && player.crouchfactor < 1 && pos.Z + height < ceilingz)
					CrouchMove(2);
				else if (crouchdir == -1 && player.crouchfactor > 0.5)
					CrouchMove(-2);
			}
		}
		else
			player.Uncrouch();

		player.crouchoffset = -(ViewHeight) * (1 - player.crouchfactor);
	}
	
	// modifying uzdoom's source code (not using Super.CrouchMove cuz i need to insert some stuff more directly)
	override void CrouchMove(int direction)
	{
		if (!player)
			return;
		
		double defaultheight = FullHeight;
		double savedheight = Height;
		double crouchspeed = direction * CROUCHSPEED;
		double oldheight = player.viewheight;
		
		player.crouchdir = direction;
		player.crouchfactor += crouchspeed;
		
		if (!IsGrounded())
			SetOrigin((pos.x, pos.y, pos.z + crouchspeed), false);
		
		// check whether the move is ok
		Height = defaultheight * player.crouchfactor;
		if (!TryMove(Pos.XY, false, NULL))
		{
			Height = savedheight;
			if (direction > 0)
			{
				// doesn't fit
				player.crouchfactor -= crouchspeed;
				
				if (!player.onGround)
					SetOrigin((pos.x, pos.y, pos.z - crouchspeed), false);
		
				return;
			}
		}
		Height = savedheight;

		player.crouchfactor = clamp(player.crouchfactor, 0.5, 1.);
		player.viewheight = ViewHeight * player.crouchfactor;
		player.crouchviewdelta = player.viewheight - ViewHeight;

		// Check for eyes going above/below fake floor due to crouching motion.
		CheckFakeFloorTriggers(pos.Z + oldheight, true);
	}
	
	override bool CanCollideWith(Actor other, bool passive)
	{
		if (other.bIsMonster && lunging && other != lungeTarget)
			return false;
		if (other.bMissile && damageTics)
			return false;
		
		return Super.CanCollideWith(other, passive);
	}
	
	override void HasReceived(Inventory item)
	{
		if (!IsPredicting() && item is "Health" && item.GetClass() != "Health" && !item.bQuiet)
			A_StartSound("delta/heal", CHAN_VOICE);
	}
	
	override Vector2 BobWeapon(double ticfrac)
	{
		let originalBob = lunging ? (0, 0) : Super.BobWeapon(ticfrac);
		double perc = 1 - airBobTics / float(MAX_AIR_BOB_TICS);
		
		Vector2 bobFlinch = (0, 0);
		if (_flinchTics)
			bobFlinch = _currentFlinch * ((_flinchTics - ticFrac) / startFlinchTics);
		
		bobFlinch.y = abs(bobFlinch.y);
		
		return originalBob * perc + bobFlinch;
	}
	
	override void CheatGive(string name, int amount)
	{
		if (name ~== "armor")
			return;
		
		if (name ~== "tensionPoints" || name ~== "tp")
		{
			if (amount < 0)
				return;
			
			if (amount == 0)
				amount = maxTensionPoints;
			
			tensionPoints = min(maxTensionPoints, tensionPoints + amount);
			tensionDrainTimer = DRAIN_TIMER_START;
		}
		else
		{
			if (name ~== "all" || name ~== "everything" || name ~== "ammo")
			{
				tensionPoints = maxTensionPoints;
				tensionDrainTimer = DRAIN_TIMER_START;
			}
			
			Super.CheatGive(name, amount);
		}
	}
	
	override void CheatTake(string name, int amount)
	{
		//A_Log("Taking " .. amount .. " of " .. name .. " away.", true);
		
		if (name ~== "armor")
			return;
			
		if (name ~== "tensionPoints" || name ~== "tp")
		{
			if (amount < 0)
				return;
			
			if (amount == 0)
			{
				tensionPoints = 0;
				return;
			}
			
			tensionPoints = max(0, tensionPoints - amount);
			tensionDrainTimer = DRAIN_TIMER_START;
		}
		else
			Super.CheatTake(name, amount);
	}
	
	override void MakeFootsteps()
	{
		if (IsPredicting())
			return;
		
		Super.MakeFootsteps();
	}
	
	// taking from uzdoom.pk3 and retooling, removing grunts entirely
	override void PlayerLandedMakeGruntSound(actor onmobj)
	{
		// [RH] only make noise if alive
		if (self.health > 0 && !Alternative)
		{
			bool isliquid = (pos.Z <= floorz) && HitFloor ();
			
			if (onmobj != NULL || !isliquid)
				A_StartSound("*land", CHAN_AUTO);
		}
	}
	
	void StartLunge(Actor target, float stopDistance)
	{
		if (!CanLunge())
			return;
		
		lungeTarget = target;
		lungeStopDistance = stopDistance;
		
		if (LungeBlocked())
		{
			if (!player)
				return;
			
			let weap = DeltaWeapon(player.ReadyWeapon);
			
			if (!weap)
				return;
			
			weap.MarkReadyToStopLunging();
			return;
		}
		
		lunging = bNoGravity = true;
		bSolid = false;
	}
	
	bool LungeBlocked()
	{
		return !CheckMove(lungeTarget.pos.XY, PCM_NOACTORS) || lungeTarget.health <= 0;
	}
	
	void HandleLunging()
	{
		if (!lunging || !player)
			return;
		if (!lungeTarget)
		{
			StopLunge();
			return;
		}
		
		Vector3 diff = level.Vec3Diff(pos, lungeTarget.pos);
		Vector3 diffUnit = diff.Unit();
		
		if (freelook && false)
			A_SetPitch(asin(diffUnit.z), SPF_INTERPOLATE);
		
		float pitchFactor = 1 - ((diffUnit.z / 2) + 0.5);
		
		//A_Log("pitch: " .. pitch .. ", factor: " .. pitchFactor);
		diff = level.Vec3Diff(pos, lungeTarget.pos.PlusZ(lungeTarget.height * pitchFactor));
		
		A_SetAngle(VectorAngle(diff.x, diff.y), SPF_INTERPOLATE);
		
		float dist = diff.Length() - radius - lungeTarget.radius;
		Vel = diffUnit * min(lungeSpeed, dist);
		
		if (dist <= lungeStopDistance + Vel.Length()
			|| (diff.XY.Length() < lungeStopDistance + Vel.Length()
			&& abs(diff.z) - height - Vel.Length() <= lungeStopDistance))
		{
			if (player && player.ReadyWeapon && player.ReadyWeapon is "DeltaWeapon")
				DeltaWeapon(player.ReadyWeapon).MarkReadyToStopLunging();
		}
		
		//A_Log("Diff: " .. diff .. ", height: " .. height);
		if (dist <= lungeStopDistance || (diff.XY.Length() < lungeStopDistance
			&& abs(diff.z) - height <= lungeStopDistance) || LungeBlocked())
		{
			StopLunge();
		}
	}
	
	void StopLunge()
	{
		Vel = (0, 0, 0);
		lunging = bNoGravity = false;
		bSolid = true;
		
		if (!player || !player.ReadyWeapon || !(player.ReadyWeapon is "DeltaWeapon"))
			return;
		
		DeltaWeapon(player.ReadyWeapon).MarkReadyToStopLunging();
	}
	
	void AddTension(double amount, bool graze = false, bool resetTimer = true)
	{
		tensionPoints = min(maxTensionPoints, tensionPoints + amount * G_SkillPropertyFloat(SKILLP_AmmoFactor) * sv_ammofactor);
		
		if (resetTimer)
			tensionDrainTimer = DRAIN_TIMER_START;
		if (graze)
			ticLastGrazed = level.Time;
	}
	
	clearscope int GetTension(double amount, bool playSound = true)
	{
		if (sv_infiniteAmmo || (FindInventory('PowerInfiniteAmmo', true) != null))
			return TP_INFINITE;
		
		if (amount < 0)
			amount = 0;
		
		if (tensionPoints < amount)
		{
			if (playSound)
				A_StartSound("delta/tp_fail", CHAN_ITEM, CHANF_LOCAL | CHANF_NOSTOP);
			
			return TP_FAIL;
		}
		
		return TP_USE;
	}
	
	bool TryTakeTension(double amount, bool playSound = true)
	{
		let tpResult = GetTension(amount, playSound);
		
		if (tpResult != TP_USE)
		{
			if (playSound && tpResult == TP_FAIL)
				A_StartSound("delta/tp_fail", CHAN_ITEM, CHANF_LOCAL | CHANF_NOSTOP);
			
			return tpResult == TP_INFINITE; // false if fail, true if infinite
		}
		
		tensionPoints -= amount;
		
		if (tensionPoints > 0)
			tensionDrainTimer = DRAIN_TIMER_START;
		else
			tensionDrainTimer = 0;
		return true;
	}
	
	protected void DrainTension()
	{
		if (sv_infiniteAmmo || (FindInventory('PowerInfiniteAmmo', true) != null))
			return;
		
		if (tensionDrainTimer > 0)
			tensionDrainTimer--;
		else if (tensionPoints > 0)
			tensionPoints = max(0, tensionPoints - 5./TICRATE);
	}
	
	protected void HandleHeartbeat()
	{
		if (IsPredicting())
			return;
		
		if (!heartbeat)
			heartbeat = LinearValueInterpolator.Create(0, 10);
		
		float _maxHealth = GetMaxHealth();
		
		// make sure heartbeat only plays if we're above 40% of our max health AND we aren't dead
		if (Health <= _maxHealth / 3. && Health > 0 && (delta_heartbeatSound == 1 || (delta_heartbeatSound == 2 && self is "KrisPlayer")))
		{
			int _targetVol = (175/3. - Health/float(GetMaxHealth()) * 100) * 2;
			
			heartbeat.Update(_targetVol);
		}
		else if (Health > 0 && delta_heartbeatSound)
			heartbeat.Update(0);
		else
			heartbeat.Reset(0);
		
		if (!IsActorPlayingSound(7))
			A_StartSound("delta/heartbeat", 7, CHANF_LOOPING, heartbeat.GetValue() / 100., 120);
		else
			A_SoundVolume(7, heartbeat.GetValue() / 100.);
	}
	
	protected virtual float GetViewRoll()
	{
		if (IsPredicting())
			return 0;
		
		let relVel = (Vel.x * cos(-Angle) - (Vel.y * sin(-Angle)), Vel.x * sin(-Angle) + Vel.y * cos(-Angle), Vel.z);
		let rollTarget = min(10, max(-10, -relVel.y * 0.25));
		
		let maxChange = 20. / TICRATE;
		
		if (abs(rollTarget - _targetRoll) > 2)
			maxChange *= 2;
		if (abs(rollTarget - _targetRoll) > 5)
			maxChange *= 2;
		if (abs(rollTarget - _targetRoll) > 10)
			maxChange *= 2;
		
		_targetRoll += min(maxChange, max(-maxChange, rollTarget - _targetRoll));
		return _targetRoll;
	}
	
	protected void HandleViewRoll()
	{
		viewRoll = (player.cheats & CF_CHASECAM) ? 0 : GetViewRoll();
	}
	
	protected void HandleIFrames()
	{
		if (damageTics < 0)
			damageTics = max(1, DAMAGE_IFRAMES) - 1; // minus one because we take a tic to initialize i-frames
		else if (damageTics > 0)
			damageTics--;
	}
	
	protected bool RalseiIsHugging()
	{
		string hug = "hugging";
		class<Inventory> hugging = hug;
		return FindInventory(hugging);
	}
	
	protected virtual void HandleRalseiHugs()
	{
		string rals = "FriendsWithRalsei";
		class<Actor> ralseiCheck = rals;
		
		if (ralseiCheck == null)
			return; // don't bother with this if we don't have the ralsei mod
		
		if (RalseiIsHugging() && !beingHugged)
		{
			if (++hugTimer == hugReactionTime)
				beingHugged = true;
		}
		else if (!RalseiIsHugging() && beingHugged)
		{
			hugTimer = 0;
			beingHugged = false;
		}
	}
	
	protected void HandleAirStuff()
	{
		if (IsGrounded())
			airTimer = 0;
		else
			airTimer++;
		
		if (IsPredicting())
			return;
		
		if (IsGrounded() && airBobTics)
			airBobTics--;
		else if (!IsGrounded() && airBobTics < MAX_AIR_BOB_TICS)
			airBobTics++;
	}
	
	protected void HandleFlinch()
	{
		if (_flinchTics > 0)
			_flinchTics--;
	}
	
	protected void CheckGraze()
	{
		if (damageTics != 0)
			return;
		
		ThinkerIterator it = ThinkerIterator.Create("Actor", STAT_DEFAULT);
		Actor mis;
		bool grazeSound;
		
		while (mis = Actor(it.Next()))
		{
			if (!mis.bMissile && !mis.bSkullfly)
				continue;
			if (!mis.bSkullfly && mis.target == self) // "target" with projectiles is used to figure out who threw it
				continue;
			
			int misDmg = mis.GetMissileDamage(0, 1);
			
			if (misDmg <= 0)
				continue;
			if (!mis.bSkullfly && mis.target && IsFriend(mis.target))
				continue;
			
			// code largely taken from ThinkerIterator documentation page
			double blockDist = (radius * 3) + (mis.radius * 3);
			double blockHeight = (height * 3) + (mis.height * 3);
			Vector3 diff = level.Vec3Diff(pos, mis.pos);
			
			if (abs(diff.x) > blockDist || abs(diff.y) > blockDist)
				continue;
			if (abs(diff.z) > blockHeight)
				continue;
			
			bool firstGraze = grazed.Find(mis) == grazed.Size();
			double grazeAmount = max(5, misDmg);
			
			GrazeEvent e;
			e.thing = self;
			e.grazeSource = mis;
			
			DeltaWarriorsEvents(EventHandler.Find('DeltaWarriorsEvents')).PlayerGrazed(e);
			
			if (firstGraze)
			{
				AddTension(grazeAmount * GetGrazeMultiplier(), true);
				grazed.Push(mis);
			}
			else
				AddTension(grazeAmount * GetGrazeMultiplier() / TICRATE, true);
			
			if (!grazeSound && !IsPredicting())
			{
				grazeSound = true;
				A_StartSound("delta/graze", 5, 0, firstGraze ? 1 : 0.5);
			}
		}
	}
	
	protected void DamageFlinch(float ang)
	{
		_flinchTics = startFlinchTics;
		_currentFlinch = (sin(ang), cos(ang)) * flinchMultiplier;
	}
	
	// retooling zdoom's implementation of freeze death for our own freeze death!
	protected action void A_DeltaFreezeDeath()
	{
		A_StartDeath(true);
		
		invoker._frozenDeath = bSolid = bShootable = bNoBlood = bPushable
			= bTelestomp = bCanPass = bSlidesOnWalls = true;
		Height = Default.Height;
		A_StartSound("delta/freeze", CHAN_BODY);

		if (!player)
			return;
		
		player.damagecount = 0;
		player.poisoncount = 0;
		player.bonuscount = 0;
	}
	
	protected action void A_StartDeath(bool freeze = false)
	{
		invoker.airTimer = 0;
		invoker.isUsingOffhand = false;
		A_Fall();
		
		if (!invoker.IsPredicting())
		{
			A_StopSound();
			A_StartSound("delta/hurt", CHAN_VOICE);
			invoker.DeltaExtraDeathStuff();
			
			// if we have partial invisibility or anything like that, turn it off
			A_SetRenderStyle(1, STYLE_Normal);
			
			// hide our weapon sprites IMMEDIATELY. classic doom and default zdoom
			// use deselect state, which would look weird since it's actually
			// animated
			if (player)
			{
				player.SetPSprite(PSP_FLASH, null);
				player.SetPSprite(PSP_WEAPON, null);
				player.SetPSprite(PSP_OFFHAND, null);
				
				if (player.FindPSprite(PSP_LEGS))
					player.SetPSprite(PSP_LEGS, null);
			}
			A_StopSound(CHAN_WEAPON);
		}
		
		if (!freeze)
			invoker.bCanPass = false;		// make sure our corpse doesn't get
											// stuck on decorations or monsters
	}
	
	protected action state A_CheckDeathLand(statelabel targetState = "FinishDeath")
	{
		if (pos.Z == floorZ && Vel.Z <= 0)
			return ResolveState(targetState);
		
		invoker.airTimer++;
		return ResolveState(null);
	}
	
	protected action void A_DeathImpact()
	{
		if (invoker.airTimer > 3)
			A_StartSound("delta/impact", CHAN_BODY, 0, 0.75);
	}
	
	virtual void DeltaExtraDeathStuff()
	{
		
	}
	
	virtual bool StartOffhand()
	{
		isUsingOffhand = true;
		return true;
	}
	
	// See if we're holding offhand or not
	action state A_CheckOffhand(statelabel failDest)
	{
		if (!player)
			return ResolveState(failDest);
		
		if (player.cmd.buttons & BT_USER1)
			return ResolveState(null);
		
		return ResolveState(failDest);
	}
	
	// Wrap up
	action void A_EndOffhand()
	{
		invoker.isUsingOffhand = false;
	}
	
	clearscope virtual bool CanUseOffhand()
	{
		return true;
	}
	
	clearscope Color GetCharacterColor()
	{
		return characterColor | 0xff000000;
	}
	
	clearscope Color GetOverhealColor()
	{
		return overhealColor | 0xff000000;
	}
	
	clearscope bool GetCrouching()
	{
		return player && player.crouchOffset != 0;
	}
	
	clearscope int GetDamageTics()
	{
		return damageTics;
	}
	
	clearscope bool GetIsUsingOffhand()
	{
		return isUsingOffhand;
	}
	
	clearscope virtual float GetGrazeMultiplier()
	{
		return 1;
	}
	
	clearscope bool IsLunging()
	{
		return lunging && lungeTarget;
	}
	
	clearscope virtual bool CanLunge()
	{
		return !GetCrouching();
	}
	
	clearscope bool IsGrounded()
	{
		if (player)
			return player.onGround;
		
		return pos.Z <= floorZ;
	}
	
	clearscope bool IsPredicting()
	{
		if (player)
			return (player.cheats & CF_PREDICTING);
		
		return false;
	}
	
	clearscope TextureID GetOffhandIconID()
	{
		return _offhandIconId;
	}
	
	States
	{
		Spawn:
			TNT1 A 1;
			Loop;
		See:
			TNT1 A 1;
			Loop;
	}
}

// used to modify projectile damage directly!
class DeltaParryDamage : Inventory
{
	Default
	{
		+Inventory.UNDROPPABLE;
		+Inventory.UNTOSSABLE;
	}
	
	override void ModifyDamage(int damage, Name damageType, out int newDamage, bool passive, Actor inflictor, Actor source, int flags)
	{
		if (passive || !inflictor || !inflictor.CountInv("DeltaParried"))
			return;
		
		newDamage = random[parryDamage](15, 20) * max(5, inflictor.GetMissileDamage(0, 1));
	}
}

class DeltaParried : Inventory {}