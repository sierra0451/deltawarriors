enum TpResult
{
	TP_FAIL = 0,
	TP_USE = 1,
	TP_INFINITE = 2
}

enum DeltaPsp
{
	PSP_LEGS = -10,
	PSP_OFFHAND = -5
}

enum HeartbeatSetting
{
	HB_OFF = 0,
	HB_ON = 1,
	HB_KRIS_ONLY = 2
}

enum DeltaRecoilType
{
	RECOIL_WEAPON,
	RECOIL_DAMAGE
}

enum DeltaCrosshairState
{
	DELTA_XHR_NEUTRAL,
	DELTA_XHR_FRIENDLY,
	DELTA_XHR_ENEMY
}

struct RecoilEvent
{
	Vector3 recoil;
	int startTime, curTime, leadInTime;
	DeltaRecoilType recoilType;
}

class DeltaPlayer : PlayerPawn abstract
{
	double tensionPoints;
	double maxTensionPoints;
	int ticLastGrazed;
	int tensionDrainTimer;
	bool beingHugged;
	int hugReactionTime;
	Actor lungeTarget;
	
	protected int airTimer; 						// when alive, used to handle coyote time. when dead, used to determine if we made a thud sound upon corpse landing
	protected int jumpBuffer, airBobTics, hugTimer;
	protected float customBobPerc;
	protected int damageTics; 						// invulnerability frames, essentially
	protected int deathTimer; 						// used for first person death animation and for "Press E to respawn" prompt
	protected Color characterColor, overhealColor;
	protected double deathPitchFP, deathPitchTP;
	
	protected float flinchMultiplier;				// wanna be able to make certain characters flinch more or flinch less at incoming damage
	protected int startFlinchTics;
	protected int shakinessMaxHealth;				// lowest possible health where we'll still be at minimum hand shakiness
	protected float minShakiness, maxShakiness;
	protected int oldShakiness;				// used for interpolation
	
	protected bool lunging;
	protected float lungeSpeed, lungeStopDistance;
	protected Vector3 preLungeVel;
	protected Array<Actor> grazed;
	
	protected bool isUsingOffhand;
	protected string offhandIcon;
	protected string characterIcon;
	
	protected LinearValueInterpolator heartbeat;
	protected LinearValueInterpolator shakiness;
	
	protected float oldAngle;
	
	private float _targetRoll;
	private bool _frozenDeath;						// using this for custom ice death that doesn't automatically shatter us lol
	
	private Vector2 _currentFlinch;					// used for weapon flinching when taking damage
	private int _flinchTics;
	
	private double _oldTurn;
	private double _turn;
	
	private TextureID _offhandIconId;
	private TextureID _characterIconId;				// used for health displays in co-op and team deathmatch
	
	private DeltaCrosshairState _crosshairState;
	
	private float _originalHeight;					// used for fixing compatibility issues with maps that use voodoo dolls
													// and conveyor belts
	
	private RecoilEvent[10] _recoils;
	
	private Array<Name> _dynamicLights;
	
	// Damage types that ignore I-frames.
	static const Name DAMAGE_TYPES_IGNORE_IFRAMES[] =
	{
		'Crush',
		'Telefrag',
		'Falling',
		'Suicide',
		'Exit',
		'Poison'
	};
	
	const MAX_AIR_BOB_TICS = 5;
	const DAMAGE_IFRAMES = 10;
	const DRAIN_TIMER_START = TICRATE * 12;			// tp lasts for 12 seconds before we start draining it
	const RECOIL_TICS = 5;
	const DEFAULT_RED_CROSSHAIR_RANGE = 500;
	
	property HugReactionTime: hugReactionTime;
	property CharacterColor: characterColor;		// mostly used for hud elements
	property OverhealColor: overhealColor;			// used for overheal bar on hud
	property FlinchMultiplier: flinchMultiplier;
	property StartFlinchTics: startFlinchTics;
	property LungeSpeed: lungeSpeed;
	property OffhandIcon: offhandIcon;
	property CharacterIcon: characterIcon;
	property ShakinessMaxHealth: shakinessMaxHealth;
	property MinShakiness: minShakiness;
	property MaxShakiness: maxShakiness;
	
	Default
	{
		Height 36;
		Radius 16;
		Speed 0.7;
		Mass 100;
		PainChance 256;
		
		Health 100;
		Player.MaxHealth 100;
		
		Player.MugShotMaxHealth -1;
		
		Player.DisplayName "DeltaPlayer";
		Player.SoundClass "delta";
		Player.ViewHeight 32.0;
		
		// strafing should be same speed as moving forward
		Player.ForwardMove 1, 1;
		Player.SideMove 1.25, 1.25;
		
		Player.AttackZOffset 12;
		Player.JumpZ 12;
		Player.GruntSpeed 3;
		Player.ViewBob 0.2;
		Player.ViewBobSpeed 12;
		Player.FlyBob 0;
		Player.InvulnerabilityMode "Reflective";
		
		DeltaPlayer.HugReactionTime 20;
		DeltaPlayer.CharacterColor Color(127, 127, 127);
		DeltaPlayer.OverhealColor Color(60, 220, 60);
		
		DeltaPlayer.FlinchMultiplier 10;
		DeltaPlayer.StartFlinchTics 5;
		DeltaPlayer.LungeSpeed 45;
		
		DeltaPlayer.OffhandIcon "";
		DeltaPlayer.CharacterIcon "";
		
		DeltaPlayer.ShakinessMaxHealth 50;
		DeltaPlayer.MinShakiness 0.2;
		DeltaPlayer.MaxShakiness 1;
		
		+PLAYERPAWN.MAKEFOOTSTEPS
		+NOICEDEATH
		+DONTGIB					// prevents us from being turned into a pile of flattened meat by crushers
	}
	
	override void BeginPlay()
	{
		_originalHeight = height;
		height = 56;
		
		Super.BeginPlay();
		
		// load icon textures before we do (most of) the rest of our initialization
		_offhandIconId = TexMan.CheckForTexture(offhandIcon);
		_characterIconId = TexMan.CheckForTexture(characterIcon);
	}
	
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		
		// fixing issues with maps that make use of voodoo dolls and currents
		if (player != NULL && player.mo == self)
		{
			fullHeight = _originalHeight;
			height = _originalHeight;
		}
		
		airTimer = 0;
		jumpBuffer = 0;
		ticLastGrazed = -1;
		hugTimer = 0;
		deathTimer = -1;
		tensionPoints = 0;
		maxTensionPoints = 250;
		tensionDrainTimer = 0;
		airBobTics = 0;
		beingHugged = false;
		lunging = false;
		isUsingOffhand = false;
		_turn = 0;
		_oldTurn = 0;
		
		_targetRoll = 0;
	}
	
	override void Travelled()
	{
		Super.Travelled();
		
		airTimer = 0;
		jumpBuffer = 0;
		ticLastGrazed = -1;
		hugTimer = 0;
		tensionPoints = 0;
		tensionDrainTimer = 0;
		airBobTics = 0;
		beingHugged = false;
		lunging = false;
		isUsingOffhand = false;
		oldAngle = angle;
		_turn = 0;
		_oldTurn = 0;
		
		_targetRoll = 0;
		Vel = (0, 0, 0);
	}
	
	override void PlayerThink()
	{
		Super.PlayerThink();
		HandleViewAngles();
		HandleTurning();
		
		if (IsPredicting())
			return;
		
		HandleHeartbeat();
		
		if (player.PlayerState == PST_DEAD)
			return;
		
		HandleFlinch();
		HandleHandedness();
		HandleCrosshair();
		HandleLunging();
		HandleIFrames();
		DrainTension();
		HandleRalseiHugs();
		HandleAirStuff();
		CheckGraze();
	}
	
	// grabbing code from uzdoom.pk3 and retooling for more preferred feeling
	override void MovePlayer()
	{
		if (!player)
			return;
		
		UserCmd cmd = player.cmd;
		bool doingMoveInput = player.buttons & (BT_MOVERIGHT | BT_MOVELEFT | BT_BACK | BT_FORWARD);
		
		// [RH] 180-degree turn overrides all other yaws
		if (player.turnticks && !lunging)
		{
			player.turnticks--;
			A_SetAngle(Angle + (180. / TURN180_TICKS), SPF_INTERPOLATE);
		}
		else if (!lunging)
			Angle += cmd.yaw * (360./65536.);

		player.onground = (pos.z <= floorz) || bOnMobj || bMBFBouncer || (player.cheats & CF_NOCLIP2);

		// killough 10/98:
		//
		// We must apply thrust to the player and bobbing separately, to avoid
		// anomalies. The thrust applied to bobbing is always the same strength on
		// ice, because the player still "works just as hard" to move, while the
		// thrust applied to the movement varies with 'movefactor'.

		//if (cmd.forwardmove | cmd.sidemove)
		{
			double forwardmove, sidemove;
			double bobfactor;
			double friction, movefactor;
			double fm, sm;
			double perc = 1 - airBobTics / float(MAX_AIR_BOB_TICS);

			[friction, movefactor] = GetFriction();
			bobfactor = friction < ORIG_FRICTION ? movefactor : ORIG_FRICTION_FACTOR;
			bobfactor *= perc;
			
			fm = cmd.forwardmove;
			sm = cmd.sidemove;
			[fm, sm] = TweakSpeeds (fm, sm);
			fm *= Speed / 256;
			sm *= Speed / 256;
			
			if (!player.onground && !bNoGravity && !waterlevel)
			{
				// [RH] allow very limited movement if not on ground.
				// [AA] but also allow authors to override it.
				ApplyAirControl(movefactor, bobfactor);
			}

			// When crouching, speed and bobbing have to be reduced
			if (CanCrouch() && player.crouchfactor != 1)
			{
				fm *= player.crouchfactor;
				sm *= player.crouchfactor;
				bobfactor *= player.crouchfactor;
			}
			
			forwardmove = fm * movefactor * (35 / TICRATE);
			sidemove = sm * movefactor * (35 / TICRATE);
			
			if (lunging)
				player.vel = (0, 0);
			else
			{
				if (forwardmove)
				{
					Bob(Angle, cmd.forwardmove * bobfactor / 256., true);
					ForwardThrust(forwardmove, Angle);
				}
				if (sidemove)
				{
					let a = Angle - 90;
					Bob(a, cmd.sidemove * bobfactor / 256., false);
					Thrust(sidemove, a);
				}
			}
			
			if (player.cheats & CF_REVERTPLEASE)
			{
				player.cheats &= ~CF_REVERTPLEASE;
				player.camera = player.mo;
			}
		}
			
		if (!IsPredicting())
		{
			if (doingMoveInput && Vel.LengthSquared() > 0)
				PlayRunning();
			else
				PlayIdle();
		}
	}
	
	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		bool ignoreIFrames = false;
		
		if (source && source.player)
			ignoreIFrames = true;
		else
		{
			foreach (damageType : DAMAGE_TYPES_IGNORE_IFRAMES)
			{
				if (mod == damageType)
				{
					ignoreIFrames = true;
					break;
				}
			}
		}
		
		if (_frozenDeath && mod != "Ice")
		{
			Vel = (0, 0, 0);
			A_FreezeDeathChunks();
		}	
		
		if (damageTics > 0 && !ignoreIFrames)
			return 0;
		
		int finalDamage = Super.DamageMobj(inflictor, source, damage, mod, flags, angle);
		
		if (finalDamage > 0 && Health > 0)
		{
			A_StartSound("delta/hurt", CHAN_VOICE, 0, 1, 0.5);
			
			if (!ignoreIFrames)
				damageTics = (inflictor && (inflictor.bIsPuff || inflictor.bIsMonster)) ? -1 : DAMAGE_IFRAMES;
			if (mod == 'Falling')
				A_StartSound("delta/fall_damage", CHAN_AUTO);
			
			if (source && source != self)
			{
				float ang = DeltaAngle(self.angle, AngleTo(inflictor)) + cfrandom(-15, 15);
				DamageFlinch(ang, finalDamage, flags);
			}
		}
		
		if (player)
			player.damageCount = min(35, player.damageCount);
		
		return finalDamage;
	}
	
	override void Die(Actor source, Actor inflictor, int dmgFlags, Name MeansOfDeath)
	{
		Super.Die(source, inflictor, dmgFlags, MeansOfDeath);
		
		if (lunging)
		{
			let oldVel = Vel;
			StopLunge();
			Vel = oldVel;
		}
		
		deathTimer = 0;
		deathPitchFP = deathPitchTP = Pitch;
	}
	
	// taking implementation from uzdoom.pk3, slightly retooling for different look on death
	override void DeathThink()
	{
		if (!IsPredicting())
			deathTimer++;
		
		if (!player)
			return;
		
		player.Uncrouch();
		player.onground = (pos.Z <= floorz);
		
		if (!_frozenDeath && player.onGround)
		{
			// Fall to ground (if not frozen)
			player.deltaviewheight = 0;
			if (player.viewheight > 6)
				player.viewheight -= deathTimer;
				
			if (player.viewheight < 6)
				player.viewheight = 6;
			
			if (player.viewHeight == 6)
			{
				if (deathPitchFP > -19.)
				{
					double lookDelta = (-19. - deathPitchFP) / 8;
					deathPitchFP += lookDelta;
				}
				
				if (abs(deathPitchTP) > 0.01)
				{
					double lookDelta = -deathPitchTP / 8;
					deathPitchTP += lookDelta;
				}
				else if (!(deathPitchTP ~== 0))
					deathPitchTP = 0;
				
				if ((player.cheats & CF_CHASECAM) || r_deathcamera)
					Pitch = deathPitchTP;
				else
					Pitch = deathPitchFP;
			}
		}
		
		player.mo.CalcHeight ();
		
		if (player.damagecount)
			player.damagecount--;
		
		if (player.poisoncount)
			player.poisoncount--;
		
		if ((player.cmd.buttons & BT_USE ||
			((deathmatch || alwaysapplydmflags) && sv_forcerespawn)) && !sv_norespawn)
		{
			if (Level.maptime >= player.respawn_time || ((player.cmd.buttons & BT_USE) && player.Bot == NULL))
			{
				player.cls = NULL;		// Force a new class if the player is using a random class
				player.playerstate = (multiplayer || level.AllowRespawn || sv_singleplayerrespawn || G_SkillPropertyInt(SKILLP_PlayerRespawn)) ? PST_REBORN : PST_ENTER;
				if (special1 > 2)
				{
					special1 = 0;
				}
			}
		}
	}
	
	// Grabbing GZDoom's player code and retooling it to work with coyote time and jump buffering
	override void CheckJump()
	{
		if (!player)
			return;
		
		// Buffer jump inputs
		if (player.cmd.buttons & BT_JUMP)
			jumpBuffer = 3;
		
		// [RH] check for jump
		if (jumpBuffer > 0)
		{
			jumpBuffer--;
			
			if (waterlevel >= 2)
			{
				Vel.Z = 4 * Speed;
			}
			else if (bNoGravity)
			{
				Vel.Z = 3.;
			}
			// airTimer < 4 instead of grounded check, allows for coyote time
			else if (level.IsJumpingAllowed() && airTimer < 4 && Vel.Z <= 0)
			{
				if (GetCrouching())
					player.crouchOffset = 0;
				
				double jumpvelz = JumpZ * 35 / TICRATE;
				double jumpfac = 0;
				
				// [BC] If the player has the high jump power, double their jump velocity.
				// (actually, pick the best factors from all active items.)
				for (let p = Inv; p != null; p = p.Inv)
				{
					let pp = PowerHighJump(p);
					if (pp)
					{
						double f = pp.Strength;
						if (f > jumpfac) jumpfac = f;
					}
				}
				if (jumpfac > 0) jumpvelz *= jumpfac;
				
				Vel.Z = jumpvelz;
				bOnMobj = false;
				jumpBuffer = 0;
				
				if (!IsPredicting())
					A_StartSound("*jump", CHAN_BODY);
			}
		}
	}
	
	override void CheckCrouch(bool totallyFrozen)
	{
		if (!player)
			return;
		
		int buttons = player.cmd.buttons;
		
		if (CanCrouch() && player.health > 0 && level.IsCrouchingAllowed())
		{
			if (!totallyfrozen)
			{
				int crouchdir = player.crouching;
				
				if (crouchdir == 0)
					crouchdir = (player.cmd.buttons & BT_CROUCH) ? -1 : 1;
				else if (player.cmd.buttons & BT_CROUCH)
					player.crouching = 0;
				
				if (crouchdir == 1 && player.crouchfactor < 1 && pos.Z + height < ceilingz)
					CrouchMove(2);
				else if (crouchdir == -1 && player.crouchfactor > 0.5)
					CrouchMove(-2);
			}
		}
		else
			player.Uncrouch();

		player.crouchoffset = -(ViewHeight) * (1 - player.crouchfactor);
	}
	
	// modifying uzdoom's source code (not using Super.CrouchMove cuz i need to insert some stuff more directly)
	override void CrouchMove(int direction)
	{
		if (!player)
			return;
		
		double defaultheight = FullHeight;
		double savedheight = Height;
		double crouchspeed = direction * CROUCHSPEED;
		double oldheight = player.viewheight;
		
		player.crouchdir = direction;
		player.crouchfactor += crouchspeed;
		
		if (!IsGrounded())
			SetOrigin((pos.x, pos.y, pos.z + crouchspeed), false);
		
		// check whether the move is ok
		Height = defaultheight * player.crouchfactor;
		if (!TryMove(Pos.XY, false, NULL))
		{
			Height = savedheight;
			if (direction > 0)
			{
				// doesn't fit
				player.crouchfactor -= crouchspeed;
				
				if (!player.onGround)
					SetOrigin((pos.x, pos.y, pos.z - crouchspeed), false);
		
				return;
			}
		}
		Height = savedheight;

		player.crouchfactor = clamp(player.crouchfactor, 0.5, 1.);
		player.viewheight = ViewHeight * player.crouchfactor;
		player.crouchviewdelta = player.viewheight - ViewHeight;

		// Check for eyes going above/below fake floor due to crouching motion.
		CheckFakeFloorTriggers(pos.Z + oldheight, true);
	}
	
	override bool CanCollideWith(Actor other, bool passive)
	{
		if (other.bIsMonster && lunging && other != lungeTarget)
			return false;
		if (other.bMissile && damageTics)
			return false;
		if (other.player)
		{
			if (other.player.cheats & CF_PREDICTING)
				return true;
			if (IsFriend(other))
				return false;
		}
		
		return Super.CanCollideWith(other, passive);
	}
	
	override bool PreTeleport(Vector3 destPos, double destAngle, int flags)
	{
		let oldAng = angle;
		let result = Super.PreTeleport(destPos, destAngle, flags);
		
		if (result)
			oldAngle -= DeltaAngle(destAngle, oldAng);
		
		return result;
	}
	
	override void HasReceived(Inventory item)
	{
		if (item is "Health" && item.GetClass() != "Health" && !item.bQuiet)
			A_StartSound("delta/heal", CHAN_VOICE);
	}
	
	override Vector2 BobWeapon(double ticfrac)
	{
		let originalBob = lunging ? (0, 0) : Super.BobWeapon(ticfrac);
		double perc = 1 - airBobTics / float(MAX_AIR_BOB_TICS);
		perc *= customBobPerc;
		
		Vector2 bobFlinch = (0, 0);
		if (_flinchTics)
			bobFlinch = _currentFlinch * ((_flinchTics - ticFrac) / startFlinchTics);
		
		bobFlinch.y = abs(bobFlinch.y);
		
		int t = level.time;
		float
			s = shakiness ? DeltaMath.Lerp(oldShakiness, shakiness.GetValue(), ticFrac)/100. : 0,
			shakeDiff = s - minShakiness,
			shakeX = sin(t/11.) * 2 - shakeDiff * sin(TICRATE*0.85*t),
			shakeY = max(0, (0.5+0.5*sin(2*t)) * 5 + shakeDiff * sin(TICRATE/2.*t));
		Vector2 shake = (shakeX, shakeY * 0.5);
		
		return originalBob * perc + bobFlinch + shake * s
			+ (DeltaMath.Lerp(_oldTurn, _turn, ticFrac), 0);
	}
	
	override void CheatGive(string name, int amount)
	{
		if (name ~== "armor")
			return;
		
		if (name ~== "tensionPoints" || name ~== "tp")
		{
			if (amount < 0)
				return;
			
			if (amount == 0)
				amount = maxTensionPoints;
			
			tensionPoints = min(maxTensionPoints, tensionPoints + amount);
			tensionDrainTimer = DRAIN_TIMER_START;
		}
		else
		{
			if (name ~== "all" || name ~== "everything" || name ~== "ammo")
			{
				tensionPoints = maxTensionPoints;
				tensionDrainTimer = DRAIN_TIMER_START;
			}
			
			Super.CheatGive(name, amount);
		}
	}
	
	override void CheatTake(string name, int amount)
	{
		if (name ~== "armor")
			return;
			
		if (name ~== "tensionPoints" || name ~== "tp")
		{
			if (amount < 0)
				return;
			
			if (amount == 0)
			{
				tensionPoints = 0;
				return;
			}
			
			tensionPoints = max(0, tensionPoints - amount);
			tensionDrainTimer = DRAIN_TIMER_START;
		}
		else
			Super.CheatTake(name, amount);
	}
	
	override void MakeFootsteps()
	{
		if (IsPredicting())
			return;
		
		Super.MakeFootsteps();
	}
	
	// taking from uzdoom.pk3 and retooling, removing grunts entirely
	override void PlayerLandedMakeGruntSound(actor onmobj)
	{
		// [RH] only make noise if alive
		if (self.health > 0 && !Alternative)
		{
			bool isliquid = (pos.Z <= floorz) && HitFloor ();
			
			if (onmobj != NULL || !isliquid)
				A_StartSound("*land", CHAN_AUTO);
		}
	}
	
	void StartLunge(Actor target, float stopDistance)
	{
		if (!CanLunge())
			return;
		
		preLungeVel = Vel;
		lungeTarget = target;
		lungeStopDistance = stopDistance;
		
		if (LungeBlocked())
		{
			StopLunge();
			return;
		}
		
		lunging = bNoGravity = true;
		bSolid = false;
	}
	
	bool LungeBlocked()
	{
		Vector3 diff = level.Vec3Diff(pos, lungeTarget.pos);
		Vector3 diffUnit = diff.Unit();
		let playMo = player.mo;
		FLineTraceData output;
		
		LineTrace(AngleTo(lungeTarget), diff.Length(), PitchTo(lungeTarget), TRF_BLOCKSELF,
			playMo.height * 0.5 * player.crouchFactor,
			data: output);
		bool pcm = CheckMove(lungeTarget.pos.XY, PCM_NOACTORS)
			&& output.HitActor;
		
		return !pcm || lungeTarget.health <= 0;
	}
	
	void HandleLunging()
	{
		if (!lunging || !player)
			return;
		
		Vector3 diff = level.Vec3Diff(pos, lungeTarget.pos);
		Vector3 diffUnit = diff.Unit();
		
		float pitchFactor = 1 - ((diffUnit.z / 2) + 0.5);
		
		diff = level.Vec3Diff(pos, lungeTarget.pos.PlusZ(lungeTarget.height * pitchFactor));
		
		A_SetAngle(VectorAngle(diff.x, diff.y), SPF_INTERPOLATE);
		
		float dist = diff.Length() - radius - lungeTarget.radius;
		Vel = diffUnit * min(lungeSpeed, dist);
		
		if (level.IsFreelookAllowed() && abs(pitch + asin(diffUnit.z)) > 15)
			A_SetPitch(-asin(diffUnit.z), SPF_INTERPOLATE);
		
		if (LungeBlocked())
		{
			StopLunge();
			Vel = preLungeVel;
			return;
		}
		
		if (dist <= lungeStopDistance + Vel.Length() || (diff.XY.Length() < lungeStopDistance
			&& abs(diff.z) - height <= lungeStopDistance + Vel.Length()))
		{
			let targetPos = vel + pos;
			StopLunge(true);
			TryMove(targetPos.XY, 0);
			player.vel = (0, 0);
		}
	}
	
	void StopLunge(bool resetVelocity = false)
	{
		Vel = resetVelocity ? (0, 0, 0) : preLungeVel;
		lunging = bNoGravity = false;
		bSolid = true;
		
		if (!player || !player.ReadyWeapon || !(player.ReadyWeapon is "DeltaWeapon"))
			return;
		
		DeltaWeapon(player.ReadyWeapon).MarkReadyToStopLunging();
	}
	
	void AddTension(double amount, bool graze = false, bool resetTimer = true)
	{
		tensionPoints = min(maxTensionPoints, tensionPoints + amount * G_SkillPropertyFloat(SKILLP_AmmoFactor) * sv_ammofactor);
		
		if (resetTimer)
			tensionDrainTimer = DRAIN_TIMER_START;
		if (graze)
			ticLastGrazed = level.Time;
	}
	
	clearscope TpResult GetTension(double amount, bool playSound = true)
	{
		if (sv_infiniteAmmo || (FindInventory('PowerInfiniteAmmo', true) != null))
			return TP_INFINITE;
		
		if (amount < 0)
			amount = 0;
		
		if (tensionPoints < amount)
		{
			if (playSound)
				A_StartSound("delta/tp_fail", CHAN_ITEM, CHANF_LOCAL | CHANF_NOSTOP);
			
			return TP_FAIL;
		}
		
		return TP_USE;
	}
	
	bool TryTakeTension(double amount, bool playSound = true)
	{
		let tpResult = GetTension(amount, playSound);
		
		if (tpResult != TP_USE)
		{
			if (playSound && tpResult == TP_FAIL)
				A_StartSound("delta/tp_fail", CHAN_ITEM, CHANF_LOCAL | CHANF_NOSTOP);
			
			return tpResult == TP_INFINITE; // false if fail, true if infinite
		}
		
		tensionPoints -= amount;
		
		if (tensionPoints > 0)
			tensionDrainTimer = DRAIN_TIMER_START;
		else
			tensionDrainTimer = 0;
		return true;
	}
	
	protected void DrainTension()
	{
		if (sv_infiniteAmmo || (FindInventory('PowerInfiniteAmmo', true) != null))
			return;
		
		if (tensionDrainTimer > 0)
			tensionDrainTimer--;
		else if (tensionPoints > 0)
			tensionPoints = max(0, tensionPoints - 5./TICRATE);
	}
	
	protected void HandleHeartbeat()
	{
		if (IsPredicting())
			return;
		if (!heartbeat)
			heartbeat = LinearValueInterpolator.Create(0, 10);
		
		float _maxHealth = GetMaxHealth();
		
		// make sure heartbeat only plays if we're above 40% of our max health AND we aren't dead
		if (Health <= _maxHealth / 3. && Health > 0 && (cl_delta_heartbeatSound == HB_ON
			|| (cl_delta_heartbeatSound == HB_KRIS_ONLY && self is "KrisPlayer")))
		{
			int _targetVol = round(250/3. - 200. * Health / GetMaxHealth());
			heartbeat.Update(_targetVol);
		}
		else if (Health > 0 && cl_delta_heartbeatSound)
			heartbeat.Update(0);
		else if (heartbeat.GetValue() != 0)
			heartbeat.Reset(0);
		
		if (!IsActorPlayingSound(7))
			A_StartSound("delta/heartbeat", 7, CHANF_LOOPING, heartbeat.GetValue() / 100., 120);
		else
			A_SoundVolume(7, heartbeat.GetValue() / 100.);
	}
	
	protected virtual float GetViewRoll()
	{
		let relVelY = (-Vel.x * sin(-Angle) - Vel.y * cos(-Angle)) / 4.;
		let rollTarget = min(10, max(-10, relVelY)) * cl_delta_leanIntensity;
		
		let maxChange = 20. / TICRATE;
		
		if (abs(rollTarget - _targetRoll) > 2)
			maxChange *= 2;
		if (abs(rollTarget - _targetRoll) > 5)
			maxChange *= 2;
		if (abs(rollTarget - _targetRoll) > 10)
			maxChange *= 2;
		
		_targetRoll += min(maxChange, max(-maxChange, rollTarget - _targetRoll));
		return _targetRoll;
	}
	
	protected virtual Vector3 GetRecoilAngles()
	{
		Vector3 recoil;
		
		for (int i = 0; i < _recoils.Size(); i++)
		{
			int start = _recoils[i].startTime, cur = _recoils[i].curTime,
				lead = _recoils[i].leadInTime;
			
			if (cur <= 0)
				continue;
			
			float factor;
			
			if (start - cur < lead)
				factor = (start - cur) / float(lead);
			else
				factor = cur / float(start - lead);
			
			factor *= _recoils[i].recoilType == RECOIL_WEAPON ? cl_delta_weaponRecoil : cl_delta_damageRecoil;
			factor *= factor;
			recoil += _recoils[i].recoil * factor;
		}
		
		return recoil;
	}
	
	protected void HandleViewAngles()
	{
		for (int i = 0; i < _recoils.Size(); i++)
		{
			if (_recoils[i].curTime <= 0)
				continue;
			
			_recoils[i].curTime--;
		}
		
		let recoil = GetRecoilAngles();
		
		if (!(player.cheats & CF_CHASECAM))
			recoil.z += GetViewRoll();
		
		A_SetViewPitch(recoil.x, SPF_INTERPOLATE);
		A_SetViewAngle(recoil.y, SPF_INTERPOLATE);
		A_SetViewRoll(recoil.z, SPF_INTERPOLATE);
	}
	
	protected void HandleTurning()
	{
		let diffAngle = DeltaAngle(oldAngle, angle);
		_oldTurn = _turn;
		
		if (abs(_turn) > 0.5)
			_turn /= 2;
		else
			_turn = 0;
		
		_turn = DeltaMath.Clamp(_turn + diffAngle*0.2, -5, 5);
		oldAngle = angle;
	}
	
	protected void HandleIFrames()
	{
		if (damageTics < 0)
			damageTics = max(1, DAMAGE_IFRAMES) - 1; // minus one because we take a tic to initialize i-frames
		else if (damageTics > 0)
			damageTics--;
	}
	
	protected bool RalseiIsHugging()
	{
		string hug = "hugging";
		class<Inventory> hugging = hug;
		return FindInventory(hugging);
	}
	
	protected virtual void HandleRalseiHugs()
	{
		string rals = "FriendsWithRalsei";
		class<Actor> ralseiCheck = rals;
		
		if (ralseiCheck == null)
			return; // don't bother with this if we don't have the ralsei mod
		
		if (RalseiIsHugging() && !beingHugged)
		{
			if (++hugTimer == hugReactionTime)
				beingHugged = true;
		}
		else if (!RalseiIsHugging() && beingHugged)
		{
			hugTimer = 0;
			beingHugged = false;
		}
	}
	
	protected void HandleAirStuff()
	{
		if (IsGrounded())
			airTimer = 0;
		else
			airTimer++;
		
		if (IsGrounded() && airBobTics)
			airBobTics--;
		else if (!IsGrounded() && airBobTics < MAX_AIR_BOB_TICS)
			airBobTics++;
	}
	
	protected void HandleFlinch()
	{
		if (_flinchTics > 0)
			_flinchTics--;
		
		if (!shakiness)
			shakiness = LinearValueInterpolator.Create(minShakiness * 100, 20);
		
		oldShakiness = shakiness.GetValue();
		
		float shakeMaxFactor = float(shakinessMaxHealth)/GetMaxHealth();
		int targetShake = DeltaMath.Lerp(maxShakiness*100., minShakiness*100.,
			(Health-1) / (shakeMaxFactor*(GetMaxHealth()-1)));
		
		if (Health > 0)
			shakiness.Update(targetShake);
		else if (shakiness.GetValue() != 0)
			shakiness.Reset(0);
	}
	
	protected void HandleHandedness()
	{
		if (IsVoodooDoll())
			return;
		
		let weapPsp = player.FindPSprite(PSP_WEAPON),
			offhandPsp = player.FindPSprite(PSP_OFFHAND),
			legsPsp = player.FindPSprite(PSP_LEGS);
		
		if (weapPsp)
			weapPsp.bFlip = weapPsp.bMirror = cl_delta_weaponHandedness;
		if (offhandPsp)
			offhandPsp.bFlip = offhandPsp.bMirror = cl_delta_weaponHandedness;
		if (legsPsp)
			legsPsp.bFlip = legsPsp.bMirror = cl_delta_weaponHandedness;
	}
	
	protected void HandleCrosshair()
	{
		if (!cl_delta_crosshairTargetChange)
		{
			_crosshairState = DELTA_XHR_NEUTRAL;
			return;
		}
		
		if (IsVoodooDoll())
			return;
		
		let curWeap = DeltaWeapon(player.ReadyWeapon);
		
		FTranslatedLineTarget t;
		FLineTraceData l;
		double ang = angle;
		double distance = curWeap ? curWeap.GetRedCrosshairRange() : DEFAULT_RED_CROSSHAIR_RANGE;
		double pitch = AimLineAttack(ang, distance, t, 0., ALF_CHECK3D);
		
		LineTrace(ang, distance, pitch, TRF_NOSKY,
			height*0.5 - floorclip + AttackZOffset * player.crouchFactor, data: l);
		
		if (!l.HitActor)
		{
			_crosshairState = DELTA_XHR_NEUTRAL;
			return;
		}
		
		if (IsFriend(l.HitActor))
			_crosshairState = DELTA_XHR_FRIENDLY;
		else if (IsHostile(l.HitActor))
			_crosshairState = DELTA_XHR_ENEMY;
		else
			_crosshairState = DELTA_XHR_NEUTRAL;
	}
	
	protected void CheckGraze()
	{
		if (damageTics != 0)
			return;
		
		ThinkerIterator it = ThinkerIterator.Create("Actor", STAT_DEFAULT);
		Actor mis;
		bool grazeSound;
		
		while (mis = Actor(it.Next()))
		{
			if (!mis.bMissile && !mis.bSkullfly)
			{
				uint misIndex = grazed.Find(mis);
				if (misIndex != grazed.Size())
					grazed.Delete(misIndex);
				
				continue;
			}
			
			if (!mis.bSkullfly && mis.target == self) // "target" with projectiles is used to figure out who threw it
				continue;
			
			int misDmg = mis.GetMissileDamage(0, 1);
			
			if (misDmg <= 0)
				continue;
			if (!mis.bSkullfly && mis.target && IsFriend(mis.target))
				continue;
			
			// code largely taken from ThinkerIterator documentation page
			double blockDist = (radius * 3) + (mis.radius * 3);
			double blockHeight = (height * 3) + (mis.height * 3);
			Vector3 diff = level.Vec3Diff(pos, mis.pos);
			
			if (abs(diff.x) > blockDist || abs(diff.y) > blockDist)
				continue;
			if (abs(diff.z) > blockHeight)
				continue;
			
			bool firstGraze = grazed.Find(mis) == grazed.Size();
			double grazeAmount = max(5, misDmg);
			
			GrazeEvent e;
			e.thing = self;
			e.grazeSource = mis;
			
			DeltaWarriorsEvents(EventHandler.Find('DeltaWarriorsEvents')).PlayerGrazed(e);
			
			if (firstGraze)
			{
				AddTension(grazeAmount * GetGrazeMultiplier(), true);
				grazed.Push(mis);
			}
			else
				AddTension(grazeAmount * GetGrazeMultiplier() / TICRATE, true);
			
			if (!grazeSound)
			{
				grazeSound = true;
				A_StartSound("delta/graze", 5, 0, firstGraze ? 1 : 0.5);
			}
		}
	}
	
	protected void DamageFlinch(float ang, int dmg, int dmgFlags)
	{
		if (dmgFlags & DMG_NO_PAIN)
			return;
		
		double damageMultiplier = min(0.25, dmg / 50.);
		int damageAddTics = max(0, min(20, dmg / 2.));
		bool isExplosion = (dmgFlags & DMG_EXPLOSION);
		
		_flinchTics = startFlinchTics + damageAddTics/2;
		_currentFlinch = (sin(ang), cos(ang)) * flinchMultiplier;
		
		double yrMult = isExplosion ? -3*sin(ang) : sin(ang),
			pMult = cos(ang);
		
		if (abs(sin(ang)) <= 0.1)
			yrMult = 0;
		if (abs(cos(ang)) <= 0.1)
			pMult = 0;
		
		AddRecoil(RECOIL_DAMAGE, 7 + damageAddTics, 2, p: -cos(ang) * flinchMultiplier * damageMultiplier,
			y: isExplosion ? yrMult * flinchMultiplier * damageMultiplier : 0,
			r: isExplosion ? 0 : yrMult * flinchMultiplier * damageMultiplier);
	}
	
	void AddRecoil(DeltaRecoilType recoilType, int startTime, int leadInTime = 0, double p = 0, double y = 0, double r = 0)
	{
		int targetIndex = -1;
		int shortestTime = -1;
		
		for (int i = 0; i < _recoils.Size(); i++)
		{
			if (_recoils[i].curTime <= 0)
			{
				targetIndex = i;
				break;
			}
			
			if (shortestTime < 0 || _recoils[i].curTime < shortestTime)
			{
				targetIndex = i;
				shortestTime = _recoils[i].curTime;
			}
		}
		
		if (targetIndex < 0)
			return;
		
		_recoils[targetIndex].startTime = _recoils[targetIndex].curTime = startTime;
		_recoils[targetIndex].leadInTime = leadInTime;
		_recoils[targetIndex].recoil = (p, y, r);
		_recoils[targetIndex].recoilType = recoilType;
	}
	
	// exists purely to be overridden with any clean-up, or any events that
	// should trigger, or anything else that needs to be done once this player
	// class dies.
	virtual void DeltaExtraDeathStuff() {}
	
	virtual bool StartOffhand()
	{
		isUsingOffhand = true;
		return true;
	}
	
	// retooling zdoom's implementation of freeze death for our own freeze death!
	protected action void A_DeltaFreezeDeath()
	{
		A_StartDeath(true);
		
		invoker._frozenDeath = bSolid = bShootable = bNoBlood = bPushable
			= bTelestomp = bCanPass = bSlidesOnWalls = true;
		Height = Default.Height;
		A_StartSound("delta/freeze", CHAN_BODY);

		if (!player)
			return;
		
		player.damagecount = 0;
		player.poisoncount = 0;
		player.bonuscount = 0;
	}
	
	protected action void A_StartDeath(bool freeze = false)
	{
		invoker.airTimer = 0;
		invoker.isUsingOffhand = false;
		A_Fall();
		
		A_StopSound();
		A_StartSound("delta/hurt", CHAN_VOICE);
		A_ClearDynamicLights();
		
		invoker.DeltaExtraDeathStuff(); // can't be an action cuz we need to be able to override it
		
		// if we have partial invisibility or anything like that, turn it off
		A_SetRenderStyle(1, STYLE_Normal);
		
		// hide our weapon sprites IMMEDIATELY. classic doom and default zdoom
		// use deselect state, which would look weird since it's actually
		// animated
		if (player)
		{
			player.SetPSprite(PSP_FLASH, null);
			player.SetPSprite(PSP_WEAPON, null);
			player.SetPSprite(PSP_OFFHAND, null);
			
			if (player.FindPSprite(PSP_LEGS))
				player.SetPSprite(PSP_LEGS, null);
		}
		A_StopSound(CHAN_WEAPON);
		
		if (!freeze)
			invoker.bCanPass = false;		// make sure our corpse doesn't get
											// stuck on decorations or monsters
	}
	
	protected action state A_CheckDeathLand(statelabel targetState = "FinishDeath")
	{
		if (pos.Z == floorZ && Vel.Z <= 0)
			return ResolveState(targetState);
		
		invoker.airTimer++;
		return ResolveState(null);
	}
	
	protected action void A_DeathImpact()
	{
		if (invoker.airTimer > 3)
			A_StartSound("delta/impact", CHAN_BODY, 0, 0.75);
	}
	
	// See if we're holding offhand or not
	action state A_CheckOffhand(statelabel failDest)
	{
		if (!player)
			return ResolveState(failDest);
		
		if (player.cmd.buttons & BT_USER1)
			return ResolveState(null);
		
		return ResolveState(failDest);
	}
	
	// Wrap up
	action void A_EndOffhand()
	{
		invoker.isUsingOffhand = false;
	}
	
	action void A_AddDynamicLight(Name lightId, Name lightDef)
	{
		if (invoker._dynamicLights.Find(lightId) == invoker._dynamicLights.Size())
			invoker._dynamicLights.Push(lightId);
		
		A_AttachLightDef(lightId, lightDef);
	}
	
	action void A_RemoveDynamicLight(Name lightId)
	{
		int lightIndex = invoker._dynamicLights.Find(lightId);
		if (lightIndex == invoker._dynamicLights.Size())
			return;
		
		if (A_RemoveLight(lightId))
		{
			invoker._dynamicLights.Delete(lightIndex);
			return;
		}
	}
	
	action void A_ClearDynamicLights()
	{
		if (!invoker._dynamicLights.Size())
			return;
		
		for (int i = invoker._dynamicLights.Size() - 1; i >= 0; i--)
		{
			A_RemoveDynamicLight(invoker._dynamicLights[i]);
		}
	}
	
	clearscope virtual bool CanUseOffhand()
	{
		return true;
	}
	
	clearscope Color GetCharacterColor()
	{
		return characterColor | 0xff000000;
	}
	
	clearscope Color GetOverhealColor()
	{
		return overhealColor | 0xff000000;
	}
	
	clearscope bool GetCrouching()
	{
		return player && player.crouchOffset != 0;
	}
	
	clearscope int GetDamageTics()
	{
		return damageTics;
	}
	
	clearscope bool GetIsUsingOffhand()
	{
		return isUsingOffhand;
	}
	
	clearscope virtual float GetGrazeMultiplier()
	{
		return 1;
	}
	
	clearscope bool IsLunging()
	{
		return lunging && lungeTarget;
	}
	
	clearscope virtual bool CanLunge()
	{
		return !GetCrouching() && !(player.cmd.buttons & BT_BACK);
	}
	
	clearscope bool IsGrounded()
	{
		return pos.Z <= floorZ || bOnMobj || bMBFBouncer || (player.cheats & CF_NOCLIP2);
	}
	
	clearscope bool IsPredicting()
	{
		if (player)
			return (player.cheats & CF_PREDICTING);
		
		return false;
	}
	
	// returns -1 if not dead, otherwise returns how many ticks this character has been dead for
	clearscope int GetDeathTimer()
	{
		return deathTimer;
	}
	
	clearscope TextureID GetOffhandIconID()
	{
		return _offhandIconId;
	}
	
	clearscope TextureID GetCharacterIconID()
	{
		return _characterIconId;
	}
	
	clearscope DeltaCrosshairState GetCrosshairState()
	{
		return _crosshairState;
	}
	
	clearscope bool IsVoodooDoll()
	{
		return !player || !player.mo || player.mo != self;
	}
	
	States
	{
		Spawn:
			TNT1 A 1;
			Loop;
		See:
			TNT1 A 1;
			Loop;
	}
}

// used to modify projectile damage directly!
class DeltaParryDamage : Inventory
{
	Default
	{
		+Inventory.UNDROPPABLE;
		+Inventory.UNTOSSABLE;
	}
	
	override void ModifyDamage(int damage, Name damageType, out int newDamage, bool passive, Actor inflictor, Actor source, int flags)
	{
		if (passive || !inflictor || !inflictor.CountInv("DeltaParried"))
			return;
		
		newDamage = random[parryDamage](15, 20) * max(5, inflictor.GetMissileDamage(0, 1));
	}
}

class DeltaParried : Inventory {}