class KrisPlayer : DeltaPlayer
{
	protected bool _isSliding;
	protected float _slideAngle;
	protected float _slideSpeed;		// normal slide speed
	protected float _slideAdjustSpeed;	// speed at which strafing will move you while sliding
	protected float _slideSlowing;		// time it takes sliding to slow to a stop on flat surface
	
	private float _currentSlideSpeed;
	private float _savedSlideSpeed;
	private int _savedSlideSpeedTimer;
	private int _slideTics;				// used for smooth transitions into sliding effects
	const MAX_SLIDE_TICS = 5;
	
	const PARRY_TP_COST = floor(0.4 * 250);
	
	Default
	{
		Height 36;
		Radius 16;
		Speed 0.8;
		Mass 100;
		
		Health 100;
		Player.MaxHealth 100;
		
		Player.DisplayName "$DELTA_CHAR_KRIS";
		Player.ViewHeight 28.0;
		
		Player.WeaponSlot 1, "KrisSword";
		Player.WeaponSlot 2, "KrisRevolver";
		Player.WeaponSlot 3, "KrisShotgun";
		Player.WeaponSlot 4, "KrisSMG";
		// Player.WeaponSlot 5, "KrisGrenadeLauncher";
		// Player.WeaponSlot 6, "KrisCrossbow";
		
		Player.StartItem "KrisSword";
		Player.StartItem "KrisRevolver";
		Player.StartItem "Clip", 15;
		Player.StartItem "DeltaParryDamage"; 	// hacky af workaround for more consistent
												// projectile parry damage
		
		Player.Face "KRF";
		
		DeltaPlayer.HugReactionTime 20;
		DeltaPlayer.CharacterColor Color(0, 162, 232);
		DeltaPlayer.OffhandIcon "SHLDPRRY";
		DeltaPlayer.CharacterIcon "graphics/krisIcon.png";
	}
	
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		
		_slideSpeed = 18;
		_slideAdjustSpeed = 3;
		_savedSlideSpeed = _slideSpeed;
		_slideSlowing = 6.6;
	}
	
	override void Travelled()
	{
		Super.Travelled();
		
		if (_isSliding)
			EndSlide();
		
		_slideTics = 0;
	}
	
	override void PlayerThink()
	{
		Super.PlayerThink();
		
		if (!IsPredicting())
			HandleSlide();
	}
	
	override void CheckJump()
	{
		if (!level.IsJumpingAllowed())
		{
			Super.CheckJump();
			return;
		}
		
		if (_isSliding)
			return;
		
		Super.CheckJump();
	}
	
	override void CheckCrouch(bool totallyFrozen)
	{
		let player = self.player;
		int buttons = player.cmd.buttons;
		
		if (CanCrouch() && player.health > 0 && level.IsCrouchingAllowed())
		{
			if (!totallyfrozen)
			{
				int crouchdir = player.crouching;
				
				if (crouchdir == 0)
					crouchdir = (player.cmd.buttons & BT_CROUCH) ? -1 : 1;
				else if (player.cmd.buttons & BT_CROUCH)
					player.crouching = 0;
				
				if (crouchdir == 1 && player.crouchfactor < 1 && pos.Z + height < ceilingz)
				{
					CrouchMove(2);
					
					if (_isSliding)
						EndSlide();
				}
				else if (crouchdir == -1 && player.crouchfactor > 0.5)
				{
					CrouchMove(-2);
					
					if (!_isSliding && (player.cmd.buttons & BT_RUN))
					{
						let dir = (GetPlayerInput(INPUT_FORWARDMOVE) / 12800., GetPlayerInput(INPUT_SIDEMOVE) / 10240.);
						
						if (abs(dir.x) > 0.1 || abs(dir.y) > 0.1)
							StartSlide(VectorAngle(dir.x, dir.y) - Angle);
					}
				}
			}
			else if (_isSliding)
				EndSlide();
		}
		else
		{
			player.Uncrouch();
			
			if (_isSliding)
				EndSlide();
		}

		player.crouchoffset = -(ViewHeight) * (1 - player.crouchfactor);
	}
	
	// make sure we're not bobbing if we're sliding
	override void CalcHeight()
	{
		let tempZ = pos.Z + ViewHeight + player.crouchViewDelta;

		if (tempZ > ceilingZ-4)
			tempZ = ceilingZ-4;
		
		Super.CalcHeight();
		
		player.viewZ = player.viewZ + (tempZ - player.viewZ) * (float(_slideTics) / MAX_SLIDE_TICS);
	}
	
	override bool CanCollideWith(Actor other, bool passive)
	{
		if (!_isSliding)
			return Super.CanCollideWith(other, passive);
		
		if (other.bIsMonster && other.mass <= 200 && (!other.player || !other.player.cheats & CF_PREDICTING))
			return false;
		
		return Super.CanCollideWith(other, passive);
	}
	
	override bool PreTeleport(Vector3 destPos, double destAngle, int flags)
	{
		let oldAng = angle;
		let result = Super.PreTeleport(destPos, destAngle, flags);
		
		if (result && _isSliding)
			_slideAngle += DeltaAngle(destAngle, oldAng);
		
		return result;
	}
	
	override void MakeFootsteps()
	{
		if (_isSliding)
			return;
		
		Super.MakeFootsteps();
	}
	
	override void PlayerLandedMakeGruntSound(actor onmobj)
	{
		if (!_isSliding)
			Super.PlayerLandedMakeGruntSound(onmobj);
	}
	
	override float GetViewRoll()
	{
		float _roll = Super.GetViewRoll();
		_roll += 3 * (float(_slideTics) / MAX_SLIDE_TICS);
		
		return _roll;
	}
	
	override void HandleRalseiHugs()
	{
		Super.HandleRalseiHugs();
		
		if (beingHugged)
		{
			A_SetMugshotState("Normal");	// call this first, otherwise the
											// second call won't always go
											// through
			A_SetMugshotState("Blush");
		}
	}
	
	override float GetGrazeMultiplier()
	{
		return GetIsUsingOffhand() ? 0.25 : 1;
	}
	
	protected void HandleSlide()
	{
		let
			slideX = cos(_slideAngle) * _currentSlideSpeed,
			slideY = -sin(_slideAngle) * _currentSlideSpeed,
			actorX = cos(Angle),
			actorY = sin(Angle),
			legsOffsetX = 3 * viewAngle / (player.fov/90),
			legsOffsetY = 80 - 3 * (pitch + viewPitch) / (player.fov/90);
		
		// 2.35 px every degree up to 34.1 looking down. 0 deg should be 48
		A_OverlayOffset(PSP_LEGS, legsOffsetX, max(38, legsOffsetY), WOF_INTERPOLATE);
			
		if (_isSliding)
		{
			if (_slideTics < MAX_SLIDE_TICS)
				_slideTics++;
			
			if (reactionTime)
				return;
			
			let
				sideInput = GetPlayerInput(INPUT_SIDEMOVE) / 10240.,
				adjustFactor = sideInput * _slideAdjustSpeed * (_currentSlideSpeed / _slideSpeed);
			
			slideX += sin(Angle) * adjustFactor;
			slideY -= cos(Angle) * adjustFactor;
			
			A_ChangeVelocity(slideX, slideY, Vel.Z, CVF_REPLACE);
			
			if (IsGrounded())
			{
				_currentSlideSpeed = max(0, _currentSlideSpeed - (_slideSlowing / TICRATE));
				
				if (!IsActorPlayingSound(6))
					A_StartSound("delta/kris/slide_loop", 6, CHANF_LOOPING, _currentSlideSpeed / _slideSpeed);
				else
					A_SoundVolume(6, _currentSlideSpeed / _slideSpeed);
				
				if (_currentSlideSpeed < 1)
				{
					EndSlide();
					_currentSlideSpeed = 0;
					_savedSlideSpeed = _slideSpeed;
				}
				else
				{
					if (_currentSlideSpeed > 1)
						_savedSlideSpeed = _currentSlideSpeed;
					else
						_savedSlideSpeed = _slideSpeed;
				}
				
				_savedSlideSpeedTimer = TICRATE / 10;
			}
			else if (IsActorPlayingSound(6))
				A_StopSound(6);
		}
		else
		{
			if (_slideTics > 0)
				_slideTics--;
				
			if (IsActorPlayingSound(6))
				A_StopSound(6);
			
			if (!IsGrounded())
				_savedSlideSpeed = max(_savedSlideSpeed, -Vel.Z * 0.75);
			else
			{
				if (_savedSlideSpeedTimer > 0)
					_savedSlideSpeedTimer--;
				else if (_savedSlideSpeedTimer != -1)
				{
					_savedSlideSpeed = _slideSpeed;
					_savedSlideSpeedTimer = -1;
				}
			}
		}
		
		customBobPerc = 1 - (float(_slideTics) / MAX_SLIDE_TICS);
	}
	
	protected void StartSlide(float slideAngle, bool resetSpeed = true)
	{
		if (!IsGrounded() || GetIsUsingOffhand())
			return;
		
		_slideAngle = slideAngle;
		_isSliding = true;
		
		if (resetSpeed)
			_currentSlideSpeed = max(_savedSlideSpeed, Vel.PlusZ(-Vel.Z).Length());
		
		if (IsPredicting())
			return;
		
		A_StartSound("delta/kris/slide_start", CHAN_AUTO);
		
		A_Overlay(PSP_LEGS, "SlideOverlay");
		let overlay = player.FindPSprite(PSP_LEGS);
		
		if (overlay)
		{
			overlay.bAddWeapon = false;
			overlay.bAddBob = false;
			overlay.bPivotPercent = true;
			A_OverlayPivot(PSP_LEGS);
		}
	}
	
	protected void EndSlide()
	{
		_isSliding = false;
		
		// prevent legs reappearing if we stop sliding as result of death
		if (Health > 0)
		{
			let psp = player.FindPSprite(PSP_LEGS);
			if (!psp)
				return;
			
			let offset = (psp.x, psp.y);
			A_Overlay(PSP_LEGS, "StopSlideOverlay");
			A_OverlayOffset(PSP_LEGS, offset.x, offset.y);
		}
	}
	
	protected action void A_SpawnDeathSoul()
	{
		Spawn("DeltaSoul", Vec3Offset(0, 0, 36));
	}
	
	protected void KrisShieldParry()
	{
		A_StartSound("delta/kris/shield_swing", CHAN_AUTO);
		AddRecoil(RECOIL_WEAPON, 10, 1, p: -1, y: 5);
		
		double distance = 120;
		Array<Actor> targets;
		double dotThreshold = 0.7; // dot product must be larger than this to count as parried
		
		ThinkerIterator it = ThinkerIterator.Create("Actor", STAT_DEFAULT);
		Actor mis;
		
		while (mis = Actor(it.Next()))
		{
			if (!mis.GetMissileDamage(0, 1) && !mis.bIsMonster)
				continue;
			if (mis.bRipper) // rippers can't be parried
				continue;
			if (!mis.bIsMonster && mis.target && IsFriend(mis.target)) // friendly projectiles shouldn't be parried
				continue;
			if (!mis.bMissile && !mis.bSkullfly)
			{
				if (!mis.bIsMonster)
					continue;
				if ((!mis.curState.InStateSequence(mis.ResolveState("Melee"))
						&& (!mis.curState.InStateSequence(mis.ResolveState("Missile")) || !(mis is "Cacodemon")))
						// we only wanna be able to parry an enemy's missile
						// state if it's a cacodemon, as that's the state they
						// use for their bite attack
					|| damageTics != 0)
					continue;
			}
			if (mis.bMissile && mis.target == self) // "target" with projectiles is used to figure out who threw it
				continue;
			
			// code largely taken from ThinkerIterator documentation page
			double blockDist = distance + (mis.radius * 1.5);
			double blockHeight = distance + (mis.height * 1.5);
			Vector3 diff = level.Vec3Diff(pos, mis.pos);
			
			if (abs(diff.x) > blockDist || abs(diff.y) > blockDist)
				continue;
			if (abs(diff.z) > blockHeight)
				continue;
			
			Vector3 forward = DeltaMath.GetActorForward(self);
			forward = forward.PlusZ(-forward.z);
			
			if ((diff dot forward) < 0.7)
				continue;
			
			targets.Push(mis);
		}
		
		float largestDot = -1;
		int largestDotIndex = -1;
		
		for (int i = 0; i < targets.Size(); i++)
		{
			let t = targets[i];
			let dir = level.Vec3Diff(pos, t.pos).Unit();
			let zOffset = 1 - abs(sin(pitch));
			let dotProduct = (zOffset*cos(angle), zOffset*sin(angle), zOffset) dot dir;
			
			if (dotProduct > largestDot)
			{
				largestDot = dotProduct;
				largestDotIndex = i;
			}
		}
		
		if (largestDotIndex == -1)
			return;
		
		TryTakeTension(PARRY_TP_COST, false);
		
		let parried = targets[largestDotIndex];
		
		A_QuakeEx(0, 10, 5, 10, 0, 10, "dsempty", QF_RELATIVE | QF_SCALEDOWN);
		A_SetBlend("white", 0.3, 12);
		A_StartSound("delta/kris/shield_parry", CHAN_AUTO, attenuation: 1.0);
		damageTics = 12;
		
		FTranslatedLineTarget t;
		double parryPitch = AimLineAttack(Angle, PLAYERMISSILERANGE, t, 0., ALF_CHECK3D);
		
		double newSpeed = parried.bMissile ? 70 : 50;
		Vector2 vecToAng = AngleToVector(angle, 1);
		Vector2 vecToPitch = AngleToVector(pitch, 1);
		Vector3 newVel = (vecToAng.x, vecToAng.y, -vecToPitch.y) * newSpeed;
		
		if (parried.bMissile)
		{
			int dam = parried.GetMissileDamage(0, 12);
			parried.SetOrigin(pos + (0, 0, viewHeight), false);
			
			parried.target = self;
			parried.tracer = null;
			
			parried.Vel = newVel;
			parried.Angle = Angle;
			parried.Pitch = parryPitch;
			parried.bForceRadiusDmg = true;
			parried.bForcePain = true;
			parried.GiveInventory("DeltaParried", 1);
		}
		else if (parried.bSkullfly)
		{
			parried.Vel = newVel;
			parried.DamageMobj(self, self, random[parryDmg](60, 90), 'Parry');
		}
		else if (parried.bIsMonster)
		{
			let forcePainFlag = !parried.bForcePain;
			
			LineAttack(angle, Distance3D(parried), parryPitch, random[parryDmg](60, 90), 'Parry', "KrisParryPuff");
		}
	}
	
	override void DeltaExtraDeathStuff()
	{
		if (_isSliding)
			EndSlide();
	}
	
	override bool StartOffhand()
	{
		if (!GetTension(PARRY_TP_COST))
			return false;
		
		return Super.StartOffhand();
	}
	
	override bool CanUseOffhand()
	{
		return Super.CanUseOffhand() && (GetTension(PARRY_TP_COST, false) != TP_FAIL);
	}
	
	States
	{
		Spawn:
			DKRS A 1
			{
				if (!IsGrounded())
					return ResolveState("Airborne");
				
				return ResolveState(null);
			}
			Loop;
		See:
			DKRS AAAABBBBAAAACCCC 1
			{
				let speedLerp = 1 - (invoker.Vel.Length() / (GetDefaultSpeed(invoker.GetClass()) * TICRATE));
				self.tics = max(1, round(1 + speedLerp * 0.75));
				
				if (!IsGrounded())
					return ResolveState("Airborne");
				
				return ResolveState(null);
			}
			Loop;
		Airborne:
			DKRS DDDDEEEEFFFF 1
			{
				if (IsGrounded())
					return ResolveState("Spawn");
				
				return ResolveState(null);
			}
			Loop;
		Pain:
			Goto Spawn;
		Death:
			DKRS G 1 A_StartDeath;
			DKRS G 1 A_CheckDeathLand;
			Wait;
		FinishDeath:
			DKRS H 5 A_DeathImpact;
			DKRS H 2;
			DKRS H 1 A_SpawnDeathSoul;
			DKRS H -1;
			Stop;
		Death.Ice:
			DKRF A 2 A_DeltaFreezeDeath;
			DKRF BCD 2;
			Goto FinishIce;
		FinishIce:
			DKRF E TICRATE;
			DKRF E 1 A_SpawnDeathSoul;
			DKRF E -1;
			Stop;
		
		// ============
		//   OVERLAYS  
		// ============
		Offhand:
			TNT1 A 0 { invoker.StartOffhand(); }
		Parry:
			DKSL A 2 { invoker.KrisShieldParry(); }
			DKSL B 2;
			DKSL C 2;
			DKSL D 4;
			DKSL E 2;
			TNT1 A 5;
			TNT1 A 1 A_EndOffhand;
			Stop;
		
		SlideOverlay:
			KRSL ABC 1;
			KRSL D 1;
			Wait;
		StopSlideOverlay:
			KRSL EFGH 1;
			TNT1 A 1;
			Stop;
	}
}

class KrisParryPuff : Actor
{
	Default
	{
		+FORCEPAIN
		+NOEXTREMEDEATH
	}
}