class KrisPlayer : DeltaPlayer
{
	protected bool _isSliding;
	protected float _slideAngle;
	protected float _slideSpeed;		// normal slide speed
	protected float _slideAdjustSpeed;	// speed at which strafing will move you while sliding
	protected float _slideSlowing;		// time it takes sliding to slow to a stop on flat surface
	
	protected bool _blushing;
	
	private float _currentSlideSpeed;
	private float _savedSlideSpeed;
	private int _savedSlideSpeedTimer;
	private int _slideTics;				// used for smooth transitions into sliding effects
	const MAX_SLIDE_TICS = 5;
	
	Default
	{
		Health 100;
		Player.MaxHealth 100;
		Speed 0.7;
		
		Player.DisplayName "Kris";
		Player.ViewHeight 30;
		
		Player.WeaponSlot 1, "KrisSword";
		Player.WeaponSlot 2, "KrisRevolver";
		Player.WeaponSlot 3, "KrisShotgun";
		Player.StartItem "KrisSword";
		Player.StartItem "KrisRevolver";
		Player.StartItem "Clip", 15;
		
		Player.Face "KRF";
		
		DeltaPlayer.HugReactionTime 20;
		DeltaPlayer.CharacterColor Color(0, 162, 232);
	}
	
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		_slideSpeed = 15;
		_slideAdjustSpeed = 3;
		_savedSlideSpeed = _slideSpeed;
		_slideSlowing = 5.5;
	}
	
	override void Travelled()
	{
		Super.Travelled();
		
		if (_isSliding)
			EndSlide();
	}
	
	override void PlayerThink()
	{
		Super.PlayerThink();
		HandleSlide();
	}
	
	override void CheckJump()
	{
		if (!level.IsJumpingAllowed())
		{
			Super.CheckJump();
			return;
		}
		
		if (_isSliding)
			return;
		
		Super.CheckJump();
	}
	
	override void CheckCrouch(bool totallyFrozen)
	{
		let player = self.player;
		int buttons = player.cmd.buttons;
		
		if (CanCrouch() && player.health > 0 && level.IsCrouchingAllowed())
		{
			if (!totallyfrozen)
			{
				int crouchdir = player.crouching;
				
				if (crouchdir == 0)
					crouchdir = (player.cmd.buttons & BT_CROUCH) ? -1 : 1;
				else if (player.cmd.buttons & BT_CROUCH)
					player.crouching = 0;
				
				if (crouchdir == 1 && player.crouchfactor < 1 && pos.Z + height < ceilingz)
				{
					CrouchMove(2);
					
					if (_isSliding)
						EndSlide();
				}
				else if (crouchdir == -1 && player.crouchfactor > 0.5)
				{
					CrouchMove(-2);
					
					if (!_isSliding && (player.cmd.buttons & BT_RUN))
					{
						let dir = (GetPlayerInput(INPUT_FORWARDMOVE) / 12800., GetPlayerInput(INPUT_SIDEMOVE) / 10240.);
						
						if (abs(dir.x) > 0.1 || abs(dir.y) > 0.1)
							StartSlide(VectorAngle(dir.x, dir.y) - Angle);
					}
				}
			}
		}
		else
		{
			player.Uncrouch();
			
			if (_isSliding)
				EndSlide();
		}

		player.crouchoffset = -(ViewHeight) * (1 - player.crouchfactor);
	}
	
	/*
	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		if (!GetIsUsingOffhand() || !source || self == source)
			return Super.DamageMobj(inflictor, source, damage, mod, flags, angle);
		
		foreach (damageType : DAMAGE_TYPES_IGNORE_IFRAMES)
		{
			if (mod == damageType)
				return Super.DamageMobj(inflictor, source, damage, mod, flags, angle);
		}
		
		bool isExplosive = flags & DMG_EXPLOSION;
		
		// A_Log("Attempting to block some of " .. damage .. (isExplosive ? " explosive damage." : " damage."));
		int finalDamage = damage;
		
		Vector3 forward = (cos(self.Angle), sin(self.Angle), 0);
		Vector3 diff = level.Vec3Diff(self.pos, inflictor.pos);
		diff.z = 0;
		float _dotProduct = forward dot diff.Unit();
		
		if (_dotProduct < 0.45)
		{
			// A_Log("Blocking failed.");
			return Super.DamageMobj(inflictor, source, finalDamage, mod, flags, angle);
		}
		
		double preventionFactor = isExplosive ? 0.75 : 0.9;
		double tensionToTake = max(0, damage * 0.5);
		
		if (!TryTakeTension(tensionToTake * (isExplosive ? 0.5 : 1)))
			tensionToTake = tensionPoints;
		
		finalDamage -= ceil(tensionToTake * preventionFactor * 2);
		// A_Log("Ended with taking " .. finalDamage .. (isExplosive ? " explosive damage" : " damage") .. ", taking " .. tensionToTake .. " TP.");
		return Super.DamageMobj(inflictor, source, finalDamage, mod, flags, angle);
	}
	*/
	
	override Vector2 BobWeapon(double ticfrac)
	{
		let originalBob = Super.BobWeapon(ticfrac),
			perc = 1 - (float(_slideTics) / MAX_SLIDE_TICS);
		
		return originalBob * perc;
	}
	
	// make sure we're not bobbing if we're sliding
	override void CalcHeight()
	{
		let tempZ = pos.Z + ViewHeight + player.crouchViewDelta;

		if (tempZ > ceilingZ-4)
			tempZ = ceilingZ-4;
		
		Super.CalcHeight();
		
		player.viewZ = player.viewZ + (tempZ - player.viewZ) * (float(_slideTics) / MAX_SLIDE_TICS);
	}
	
	override bool CanCollideWith(Actor other, bool passive)
	{
		if (!_isSliding)
			return Super.CanCollideWith(other, passive);
		
		//A_Log("Collided with mass of " .. other.mass);
		
		if (other.bIsMonster && other.mass <= 200)
			return false;
		
		return Super.CanCollideWith(other, passive);
	}
	
	override bool PreTeleport(Vector3 destPos, double destAngle, int flags)
	{
		_slideAngle += Angle - destAngle;
		return Super.PreTeleport(destPos, destAngle, flags);
	}
	
	override void PlayerLandedMakeGruntSound(actor onmobj)
	{
		if (!_isSliding)
			Super.PlayerLandedMakeGruntSound(onmobj);
	}
	
	override float GetViewRoll()
	{
		float _roll = Super.GetViewRoll();
		
		_roll += 3 * (float(_slideTics) / MAX_SLIDE_TICS);
		return _roll;
	}
	
	override void HandleRalseiHugs()
	{
		Super.HandleRalseiHugs();
		
		if (beingHugged)
		{
			A_SetMugshotState("Normal");	// call this first, otherwise the
											// second call won't always go
											// through
			A_SetMugshotState("Blush");
		}
	}
	
	override float GetGrazeMultiplier()
	{
		return GetIsUsingOffhand() ? 0.25 : 1;
	}
	
	protected void HandleSlide()
	{
		let
			slideX = cos(_slideAngle) * _currentSlideSpeed,
			slideY = -sin(_slideAngle) * _currentSlideSpeed,
			actorX = cos(Angle),
			actorY = sin(Angle);
		
		if (_isSliding)
		{
			if (_slideTics < MAX_SLIDE_TICS)
				_slideTics++;
			
			let
				sideInput = GetPlayerInput(INPUT_SIDEMOVE) / 10240.,
				adjustFactor = sideInput * _slideAdjustSpeed * (_currentSlideSpeed / _slideSpeed);
			
			slideX += sin(Angle) * adjustFactor;
			slideY -= cos(Angle) * adjustFactor;
			
			A_ChangeVelocity(slideX, slideY, Vel.Z, CVF_REPLACE);
			
			if (player.onGround)
			{
				_currentSlideSpeed = max(0, _currentSlideSpeed - (_slideSlowing / TICRATE));
				
				if (!IsActorPlayingSound(6))
					A_StartSound("delta/kris/slide", 6, CHANF_LOOPING, _currentSlideSpeed / _slideSpeed);
				else
					A_SoundVolume(6, _currentSlideSpeed / _slideSpeed);
				
				if (_currentSlideSpeed < 1)
				{
					EndSlide();
					_currentSlideSpeed = 0;
					_savedSlideSpeed = _slideSpeed;
				}
				else
				{
					if (_currentSlideSpeed > 1)
						_savedSlideSpeed = _currentSlideSpeed;
					else
						_savedSlideSpeed = _slideSpeed;
				}
				
				_savedSlideSpeedTimer = TICRATE / 10;
			}
			else if (IsActorPlayingSound(6))
				A_StopSound(6);
		}
		else
		{
			if (_slideTics > 0)
				_slideTics--;
				
			if (IsActorPlayingSound(6))
				A_StopSound(6);
			
			if (!player.onGround)
				_savedSlideSpeed = max(_savedSlideSpeed, -Vel.Z * 0.75);
			else
			{
				if (_savedSlideSpeedTimer > 0)
					_savedSlideSpeedTimer--;
				else if (_savedSlideSpeedTimer != -1)
				{
					_savedSlideSpeed = _slideSpeed;
					_savedSlideSpeedTimer = -1;
				}
			}
		}
	}
	
	protected void StartSlide(float slideAngle, bool resetSpeed = true)
	{
		if (!player.onGround || GetIsUsingOffhand())
			return;
		
		_slideAngle = slideAngle;
		_isSliding = true;
		
		if (resetSpeed)
			_currentSlideSpeed = max(_savedSlideSpeed, Vel.PlusZ(-Vel.Z).Length());
		
		// start slide effects
		
	}
	
	protected void EndSlide()
	{
		_isSliding = false;
		
		// remove sliding effects
		
	}
	
	protected action void A_SpawnDeathSoul()
	{
		Spawn("DeltaSoul", Vec3Offset(0, 0, 36));
	}
	
	protected void KrisShieldParry()
	{
		A_QuakeEx(0, 5, 1, 10, 0, 1, "dsempty", QF_RELATIVE | QF_WAVE | QF_SCALEDOWN, 0, 1, -1, rollWave: 5);
		A_StartSound("delta/kris/shield_swing", CHAN_AUTO);
		
		double distance = 120;
		Array<Actor> targets;
		double dotThreshold = 0.7; // dot product must be larger than this to count as parried
		
		ThinkerIterator it = ThinkerIterator.Create("Actor", STAT_DEFAULT);
		Actor mis;
		
		while (mis = Actor(it.Next()))
		{
			/*A_Log("Mis: " .. mis.GetTag() .. ", missle/skullfly: " .. (mis.bMissile || mis.bSkullfly)
				.. ", target: " .. (mis.target ? mis.target.GetTag() : "") .. ", damage: " .. mis.damage);*/
			
			if (mis.Damage == 0)
				continue;
			if (mis.bRipper || mis.bFriendly) // rippers can't be parried, friendlies shouldn't be parried
				continue;
			if (!mis.bMissile && !mis.bSkullfly)
				continue;
			if (!mis.bSkullfly && mis.target == self) // "target" with projectiles is used to figure out who threw it
				continue;
			
			// code largely taken from ThinkerIterator documentation page
			double blockDist = distance + (mis.radius * 1.5);
			double blockHeight = distance + (mis.height * 1.5);
			Vector3 diff = level.Vec3Diff(pos, mis.pos);
			
			if (abs(diff.x) > blockDist || abs(diff.y) > blockDist)
				continue;
			if (abs(diff.z) > blockHeight)
				continue;
			
			Vector3 forward = (cos(Angle), sin(Angle), 0);
			
			if ((diff dot forward) < 0.7)
				continue;
			
			targets.Push(mis);
		}
		
		if (!targets.Size())
		{
			AddTension(80);
			return;
		}
		
		A_QuakeEx(0, 10, 5, 10, 0, 10, "dsempty", QF_RELATIVE | QF_SCALEDOWN);
		A_SetBlend("white", 0.3, 12);
		A_StartSound("delta/kris/shield_parry", CHAN_AUTO, attenuation: 1.0);
		damageTics = 12;
		
		foreach (target : targets)
		{
			if (target.bMissile)
			{
				target.target = self;
				target.tracer = null;
				
				target.bForceRadiusDmg = true;
				target.bSeekerMissile = false;
				
				let oldVel = target.Vel;
				let newSpeed = 70;
				
				target.SetOrigin(pos + (0, 0, viewHeight), false);
				target.A_ChangeVelocity(cos(Angle) * newSpeed, sin(Angle) * newSpeed,
					-sin(Pitch) * newSpeed, CVF_REPLACE);
				
				//A_Log("oldVel: " .. oldVel .. ", newVel: " .. target.Vel);
				
				target.bStrifeDamage = true;
				target.SetDamage(target.damage * 6);
			}
			
			if (target.bSkullfly)
			{
				let newSpeed = 50;
				
				target.DamageMobj(self, self, random[parryDmg](60, 90), 'Parry');
				target.A_ChangeVelocity(cos(Angle) * newSpeed, sin(Angle) * newSpeed,
					-sin(Pitch) * newSpeed, CVF_REPLACE);
				target.bStrifeDamage = true;
				target.SetDamage(target.damage * 6);
			}
		}
	}
	
	protected action state A_ShieldHoldLogic()
	{
		let dp = DeltaPlayer(self);
		dp.ViewBob = 0.1;
		dp.Speed = 0.35;
		dp.AddTension(7. / TICRATE, resetTimer: false);
		return A_CheckOffhand("PutAwayShield");
	}
	
	override bool CanUseOffhand()
	{
		return Super.CanUseOffhand() && TryTakeTension(80);
	}
	
	States
	{
		Spawn:
			DKRS A 1
			{
				if (!player.OnGround)
					return ResolveState("Airborne");
				if (invoker.beingHugged)
					return ResolveState("Blush");
				
				return ResolveState(null);
			}
			Loop;
		See:
			DKRS AAAABBBBAAAACCCC 1
			{
				let speedLerp = 1 - (invoker.Vel.Length() / (GetDefaultSpeed(invoker.GetClass()) * TICRATE));
				self.tics = max(1, round(1 + speedLerp * 0.75));
				
				if (!player.OnGround)
					return ResolveState("Airborne");
				if (!(player.buttons & (BT_MOVERIGHT | BT_MOVELEFT | BT_BACK | BT_FORWARD)))
					return ResolveState("Spawn");
				if (invoker.beingHugged)
					return ResolveState("BlushWalk");
				
				return ResolveState(null);
			}
			Loop;
		Blush:
			DKRS I 1
			{
				if (!player.OnGround)
					return ResolveState("Airborne");
				if (!invoker.beingHugged)
					return ResolveState("Spawn");
				if (player.buttons & (BT_MOVERIGHT | BT_MOVELEFT | BT_BACK | BT_FORWARD))
					return ResolveState("See");
				
				return ResolveState(null);
			}
			Loop;
		BlushWalk:
			DKRS IIIIJJJJIIIIKKKK 1
			{
				let speedLerp = 1 - (invoker.Vel.Length() / (GetDefaultSpeed(invoker.GetClass()) * TICRATE));
				self.tics = max(1, round(1 + speedLerp * 0.75));
				
				if (!player.OnGround)
					return ResolveState("Airborne");
				if (!(player.buttons & (BT_MOVERIGHT | BT_MOVELEFT | BT_BACK | BT_FORWARD)))
					return ResolveState("Spawn");
				if (!invoker.beingHugged)
					return ResolveState("See");
				
				return ResolveState(null);
			}
			Loop;
		Airborne:
			DKRS DDDDEEEEFFFF 1
			{
				if (player.OnGround)
					return ResolveState("Spawn");
				
				return ResolveState(null);
			}
			Loop;
		Pain:
			Goto Spawn;
		Death:
			DKRS G 1
			{
				A_StartDeath();
				invoker.EndSlide();
			}
			DKRS G 1 A_CheckDeathLand;
			Wait;
		FinishDeath:
			DKRS H 5 A_DeathImpact;
			DKRS H 2;
			DKRS H 1 A_SpawnDeathSoul;
			DKRS H -1;
			Stop;
		Death.Ice:
			DKRF A 2 A_DeltaFreezeDeath;
			DKRF BCD 2;
			Goto FinishIce;
		FinishIce:
			DKRF E TICRATE;
			DKRF E 1 A_SpawnDeathSoul;
			DKRF E -1;
			Stop;
		
		// ============
		//   OVERLAYS  
		// ============
		Offhand:
			TNT1 A 0 { invoker.StartOffhand(); }
		Parry:
			DKSL G 2 { invoker.KrisShieldParry(); }
			DKSL H 2;
			DKSL I 4;
			DKSL J 2;
			TNT1 A 5;
			TNT1 A 1 A_EndOffhand;
			Stop;
	}
}