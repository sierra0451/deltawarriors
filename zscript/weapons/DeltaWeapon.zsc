enum DeltaCrosshairState
{
	DELTA_XHR_NEUTRAL,
	DELTA_XHR_FRIENDLY,
	DELTA_XHR_ENEMY
}

class DeltaWeapon : Weapon
{
	protected float _redCrosshairRange;	// maximum distance an enemy can be at from player and still have red crosshairs when aimed at
	protected float _maxLungeDistance;	// maximum distance the lunge check will detect targets from
	protected float _stopLungeDistance;	// distance user must be at during lunge before they stop and attack
	protected string _altFireIcon;		// used for displaying alt fire key and cost (keep as null if you don't want anything there)
	protected string _crosshair;
	
	private bool _lungeReadyToStop;
	private TextureID _altFireIconId;
	private TextureID _crosshairId;
	private DeltaCrosshairState _crosshairState;
	
	property RedCrosshairRange: _redCrosshairRange;
	property MaxLungeDistance: _maxLungeDistance;
	property StopLungeDistance: _stopLungeDistance;
	property AltFireIcon: _altFireIcon;
	property Crosshair: _crosshair;
	
	Default
	{
		Weapon.BobStyle "Smooth";
		Weapon.BobSpeed 2.5;
		DeltaWeapon.RedCrosshairRange PLAYERMISSILERANGE;
		DeltaWeapon.MaxLungeDistance -1;
		DeltaWeapon.StopLungeDistance 5;
	}
	
	States
	{
		OffhandStart:
			TNT1 A 1 A_StartOffhand;
		OffhandLoop:
			TNT1 A 1 A_CheckOffhand;
			Wait;
	}
	
	override void BeginPlay()
	{
		Super.BeginPlay();
		_altFireIconId = TexMan.CheckForTexture(_altFireIcon);
		_crosshairId = TexMan.CheckForTexture(_crosshair);
	}
	
	override void DoEffect()
	{
		Super.DoEffect();
		HandleCrosshair();
	}
	
	protected void HandleCrosshair()
	{
		let ply = owner.player;
		if (!ply)
			return;
		
		let plyMo = owner.player.mo;
		
		if (!plyMo)
			return;
		
		FTranslatedLineTarget t;
		FLineTraceData l;
		double ang = plyMo.Angle;
		double distance = _redCrosshairRange;
		double pitch = plyMo.AimLineAttack(ang, distance, t, 0., ALF_CHECK3D);
		
		plyMo.LineTrace(ang, distance, pitch, TRF_NOSKY,
			plyMo.height*0.5 - plyMo.floorclip + plyMo.AttackZOffset*ply.crouchFactor, data: l);
		
		if (!l.HitActor)
		{
			_crosshairState = DELTA_XHR_NEUTRAL;
			return;
		}
		
		if (plyMo.IsFriend(l.HitActor))
			_crosshairState = DELTA_XHR_FRIENDLY;
		else if (plyMo.IsHostile(l.HitActor))
			_crosshairState = DELTA_XHR_ENEMY;
		else
			_crosshairState = DELTA_XHR_NEUTRAL;
	}
	
	virtual bool TryUseTension(double amount)
	{
		let deltaOwner = DeltaPlayer(owner);
		
		if (amount < 0 || !deltaOwner)
			return false;
		
		return deltaOwner.TryTakeTension(amount);
	}
	
	action void A_StartRaiseWeapon()
	{
		// some code taken from A_Raise code: https://github.com/UZDoom/UZDoom/blob/41ca20c1c30decbe70da21505785fbec6bb83cd6/wadsrc/static/zscript/actors/inventory/weapons.zs#L307
		if (player == null)
			return;
		if (player.PendingWeapon != WP_NOCHANGE)
		{
			player.mo.DropWeapon();
			return;
		}
		if (player.ReadyWeapon == null)
			return;
		
		let psp = player.GetPSprite(PSP_WEAPON);
		
		if (!psp)
			return;
		
		A_SetCrosshair(-1);
		
		// set weapon sprite upfront immediately, we want to do our own deploy animations
		psp.y = WEAPONTOP;
	}
	
	action void A_FinishRaiseWeapon()
	{
		let psp = player.GetPSprite(PSP_WEAPON);
		
		if (!psp)
			return;
		
		psp.SetState(player.ReadyWeapon.GetReadyState());
	}
	
	action state A_DeltaWeaponReady(int flags = 0)
	{
		if (!(flags & WRF_NOFIRE) && (player.cmd.buttons & BT_USER1))
		{
			if (DeltaPlayer(invoker.owner).StartOffhand())
				return ResolveState("OffhandStart");
		}
		
		A_WeaponReady(flags);
		return ResolveState(null);
	}
	
	action void A_SwapWeapon()
	{
		// some code taken from A_Lower code:
		// https://github.com/UZDoom/UZDoom/blob/41ca20c1c30decbe70da21505785fbec6bb83cd6/wadsrc/static/zscript/actors/inventory/weapons.zs#L259
		if (player == null)
			return;
		if (player.ReadyWeapon == null)
			return;
		
		let psp = player.GetPSprite(PSP_WEAPON);
		
		if (!psp)
			return;
		
		ResetPSprite(psp);
		
		// [RH] Clear the flash state. Only needed for Strife.
		player.SetPsprite(PSP_FLASH, null);
		player.mo.BringUpWeapon ();
		return;
	}
	
	action state A_DoLunge(state attackState)
	{
		let deltaOwner = DeltaPlayer(self);
		if (!deltaOwner || !deltaOwner.CanLunge()
			|| invoker._lungeReadyToStop || (player.cmd.buttons & BT_BACK))
		{
			invoker._lungeReadyToStop = false;
			return attackState;
		}
		
		if (!deltaOwner.IsLunging())
		{
			Actor currMo, targetMo;
			double shortestDistance = invoker._maxLungeDistance + self.radius;
			
			let iter = BlockThingsIterator.Create(deltaOwner, shortestDistance);
			
			while (iter.Next())
			{
				currMo = iter.thing;
				
				if (!currMo || (currMo.health <= 0)
					|| (!currMo.bIsMonster && !(currMo is "PlayerPawn"))
					|| invoker.owner.IsFriend(currMo)) continue;
				
				Vector3 diff = level.Vec3Diff(pos, currMo.pos);
				Vector3 diffNorm = diff.Unit();
				double targetAngle = VectorAngle(diff.x, diff.y);
				double targetPitch = asin(diffNorm.z);
				double distance = diff.Length();
				let forward = DeltaMath.GetActorForward(deltaOwner, false);
				
				if ((diff.x, diff.y).Unit() dot (forward.x, forward.y) < 0.75)
					continue;
				
				//A_Log("target: " .. targetPitch .. ", pitch: " .. deltaOwner.pitch .. ", abs diff: " .. abs(targetPitch - deltaOwner.pitch));
				
				if (abs(targetPitch) > 80)
					continue;
				
				if (distance <= shortestDistance)
				{
					shortestDistance = distance;
					targetMo = currMo;
				}
				
				if (shortestDistance <= invoker._stopLungeDistance)
					return attackState;
			}
			
			// skip lunge and immediately attack if we don't have a target
			// or if our target is a charging lost soul or equivalent
			// (i.e. if lunging at them would end up hurting us)
			if (!targetMo)
				return attackState;
			if (targetMo.bSkullfly)
				return attackState;
			
			deltaOwner.StartLunge(targetMo, invoker._stopLungeDistance);
		}
		
		if (invoker._lungeReadyToStop)
		{
			invoker._lungeReadyToStop = false;
			return attackState;
		}
		
		return ResolveState(null);
	}
	
	action void A_StartOffhand()
	{
		invoker.owner.A_Overlay(PSP_OFFHAND, "Offhand");
		invoker.owner.A_OverlayFlags(PSP_OFFHAND, PSPF_ADDBOB, true);
	}
	
	action state A_CheckOffHand(bool bob = false, statelabel dest = "Select")
	{
		A_DeltaWeaponReady(WRF_NOFIRE | WRF_NOSWITCH);
		
		let deltaOwner = DeltaPlayer(invoker.owner);
		
		if (deltaOwner.GetIsUsingOffhand())
			return ResolveState(null);
		
		if (deltaOwner.player.PendingWeapon == WP_NOCHANGE)
			return ResolveState(dest);
		
		A_SwapWeapon();
		return ResolveState(null);
	}
	
	action void A_AddRecoil(int startTime, int leadInTime = 0, double p = 0, double y = 0, double r = 0)
	{
		DeltaPlayer(invoker.owner).AddRecoil(startTime, leadInTime, p, y, r);
	}
	
	void MarkReadyToStopLunging()
	{
		_lungeReadyToStop = true;
	}
	
	void ResetReadyToStopLunging()
	{
 		_lungeReadyToStop = false;
	}
	
	ui TextureID GetAltFireIcon()
	{
		return _altFireIconId;
	}
	
	ui TextureID GetCrosshair()
	{
		return _crosshairId;
	}
	
	clearscope DeltaCrosshairState GetCrosshairState()
	{
		return _crosshairState;
	}
}