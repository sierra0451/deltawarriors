class DeltaWeapon : Weapon
{
	protected float _maxLungeDistance;	// maximum distance the lunge check will detect targets from
	protected float _stopLungeDistance;	// distance user must be at during lunge before they stop and attack
	protected string _altFireIcon;		// used for displaying alt fire key and cost (keep as null if you don't want anything there)
	
	private bool _lungeReadyToStop;
	private TextureID _altFireIconId;
	
	property MaxLungeDistance: _maxLungeDistance;
	property StopLungeDistance: _stopLungeDistance;
	property AltFireIcon: _altFireIcon;
	
	Default
	{
		Weapon.BobStyle "Smooth";
		Weapon.BobSpeed 2.5;
		DeltaWeapon.MaxLungeDistance 120;
		DeltaWeapon.StopLungeDistance 20;
	}
	
	States
	{
		OffhandStart:
			TNT1 A 1 A_StartOffhand;
		OffhandLoop:
			TNT1 A 1 A_CheckOffhand;
			Wait;
	}
	
	override void BeginPlay()
	{
		Super.BeginPlay();
		_altFireIconId = TexMan.CheckForTexture(_altFireIcon);
	}
	
	virtual bool TryUseTension(double amount)
	{
		if (amount < 0)
			return false;
		if (!(owner is "DeltaPlayer"))
			return false;
		
		return DeltaPlayer(owner).TryTakeTension(amount);
	}
	
	action void A_StartRaiseWeapon()
	{
		// some code taken from A_Raise code: https://github.com/UZDoom/UZDoom/blob/41ca20c1c30decbe70da21505785fbec6bb83cd6/wadsrc/static/zscript/actors/inventory/weapons.zs#L307
		if (player == null)
			return;
		if (player.PendingWeapon != WP_NOCHANGE)
		{
			player.mo.DropWeapon();
			return;
		}
		if (player.ReadyWeapon == null)
			return;
		
		let psp = player.GetPSprite(PSP_WEAPON);
		
		if (!psp)
			return;
		
		// set weapon sprite upfront immediately, we want to do our own deploy animations
		psp.y = WEAPONTOP;
	}
	
	action void A_FinishRaiseWeapon()
	{
		let psp = player.GetPSprite(PSP_WEAPON);
		
		if (!psp)
			return;
		
		psp.SetState(player.ReadyWeapon.GetReadyState());
	}
	
	action state A_DeltaWeaponReady(int flags = 0)
	{
		if (!(flags & WRF_NOFIRE) && (player.cmd.buttons & BT_USER1))
		{
			if (DeltaPlayer(invoker.owner).StartOffhand())
				return ResolveState("OffhandStart");
		}
		
		A_WeaponReady(flags);
		return ResolveState(null);
	}
	
	action void A_SwapWeapon()
	{
		// some code taken from A_Lower code:
		// https://github.com/UZDoom/UZDoom/blob/41ca20c1c30decbe70da21505785fbec6bb83cd6/wadsrc/static/zscript/actors/inventory/weapons.zs#L259
		if (player == null)
			return;
		if (player.ReadyWeapon == null)
			return;
		
		let psp = player.GetPSprite(PSP_WEAPON);
		
		if (!psp)
			return;
		
		ResetPSprite(psp);
		
		// [RH] Clear the flash state. Only needed for Strife.
		player.SetPsprite(PSP_FLASH, null);
		player.mo.BringUpWeapon ();
		return;
	}
	
	action state A_DoLunge(state attackState)
	{
		let deltaOwner = DeltaPlayer(self);
		if (!deltaOwner || !deltaOwner.CanLunge()
			|| invoker._lungeReadyToStop || (player.cmd.buttons & BT_BACK))
		{
			invoker._lungeReadyToStop = false;
			return attackState;
		}
		
		if (!deltaOwner.IsLunging())
		{
			Actor currMo, targetMo;
			double shortestDistance = invoker._maxLungeDistance + self.radius;
			
			let iter = BlockThingsIterator.Create(deltaOwner, shortestDistance);
			
			while (iter.Next())
			{
				currMo = iter.thing;
				
				if (!currMo || (currMo.health <= 0)
					|| (!currMo.bIsMonster && !(currMo is "PlayerPawn"))
					|| invoker.owner.IsFriend(currMo)) continue;
				
				Vector3 diff = level.Vec3Diff(pos, currMo.pos);
				double targetAngle = VectorAngle(diff.x, diff.y);
				double targetPitch = sin(diff.z);
				double distance = diff.Length();
				let forward = DeltaMath.GetActorForward(deltaOwner, false);
				
				if ((diff.x, diff.y).Unit() dot (forward.x, forward.y) < 0.75)
					continue;
				
				//A_Log("target: " .. targetPitch .. ", pitch: " .. deltaOwner.pitch .. ", abs diff: " .. abs(targetPitch - deltaOwner.pitch));
				
				if (abs(targetPitch - deltaOwner.pitch) > 45)
					continue;
				
				if (distance <= shortestDistance)
				{
					shortestDistance = distance;
					targetMo = currMo;
				}
				
				if (shortestDistance <= invoker._stopLungeDistance)
					return attackState;
			}
			
			// skip lunge and immediately attack if we don't have a target
			// or if our target is a charging lost soul or equivalent
			// (i.e. if lunging at them would end up hurting us)
			if (!targetMo || targetMo.bSkullfly)
				return attackState;
			
			deltaOwner.StartLunge(targetMo, invoker._stopLungeDistance);
		}
		
		if (invoker._lungeReadyToStop)
		{
			invoker._lungeReadyToStop = false;
			return attackState;
		}
		
		return ResolveState(null);
	}
	
	action void A_StartOffhand()
	{
		invoker.owner.A_Overlay(PSP_OFFHAND, "Offhand");
		invoker.owner.A_OverlayFlags(PSP_OFFHAND, PSPF_ADDBOB, true);
	}
	
	action state A_CheckOffHand(bool bob = false, statelabel dest = "Select")
	{
		A_DeltaWeaponReady(WRF_NOFIRE | WRF_NOSWITCH);
		
		let deltaOwner = DeltaPlayer(self);
		
		if (deltaOwner.GetIsUsingOffhand())
			return ResolveState(null);
		
		if (deltaOwner.player.PendingWeapon == WP_NOCHANGE)
			return ResolveState(dest);
		
		A_SwapWeapon();
		return ResolveState(null);
	}
	
	void MarkReadyToStopLunging()
	{
		_lungeReadyToStop = true;
	}
	
	ui TextureID GetAltFireIcon()
	{
		return _altFireIconId;
	}
}