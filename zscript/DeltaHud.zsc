struct DamageIndicatorInfo
{
	int timer;
	Vector3 sourcePos;
}

struct GrazeIndicatorInfo
{
	int timer;
	Actor grazing;
	Vector3 sourcePos;
}

class DeltaHud : BaseStatusBar
{
	private double _hBorder, _vBorder;
	private double _oldAngle, _currAngle;
	private Vector3 _oldPos, _currPos;
	private Vector2 _universalScale;
	private HUDFont _consoleFont, _drHudFont;
	private TextureID _hpText, _tpText, _tpMaxText, _tpHighlight,
		_leftPanelBack, _vignette, _infiniteText, _damageIndicator,
		_grazeIndicator;
	private double _oldTp;
	DynamicValueInterpolator _tpInterp;
	private DamageIndicatorInfo[10] damageIndicators;
	private GrazeIndicatorInfo[10] grazeIndicators;
	
	const DAMAGE_INDICATOR_TIME = floor(TICRATE * 2);
	const DAMAGE_INDICATOR_FADE_TIME = floor(TICRATE * 0.75);
	const GRAZE_INDICATOR_TIME = floor(TICRATE * 0.25);
	
	enum CONTROL_ICON_IDS
	{
		DELTA_CONTROLICON_TEXT = 0, // use text for this one!
		
		DELTA_CONTROLICON_MOUSE1, DELTA_CONTROLICON_MOUSE2, DELTA_CONTROLICON_MOUSE3,
		DELTA_CONTROLICON_MOUSE4, DELTA_CONTROLICON_MOUSE5, DELTA_CONTROLICON_MOUSE6,
		DELTA_CONTROLICON_MOUSE7, DELTA_CONTROLICON_MOUSE8,
		
		DELTA_CONTROLICON_MAX
	}
	
	private TextureID[DELTA_CONTROLICON_MAX] controlIcons;
	
	enum AMMO_ICON_TYPES
	{
		DELTA_AMMOICON_NONE = 0,
		
		DELTA_AMMOICON_BULLETS, DELTA_AMMOICON_SHELLS, DELTA_AMMOICON_ROCKETS,
		DELTA_AMMOICON_PLASMA, DELTA_AMMOICON_FUEL,
		
		DELTA_AMMOICON_MAX
	}
	
	private TextureID[DELTA_AMMOICON_MAX] ammoIcons;
	
	override void Init()
	{
		Super.Init();
		
		_hBorder = 30;
		
		_drHudFont = HUDFont.Create("DRHUDFONT");
		_consoleFont = HUDFont.Create("DRCONFONT");
		
		_hpText = TexMan.CheckForTexture("DRHPTEXT");
		_tpText = TexMan.CheckForTexture("DRTPTEXT");
		_tpMaxText = TexMan.CheckForTexture("DRHUDMAX");
		_tpHighlight = TexMan.CheckForTexture("DRTPHLGT");
		_leftPanelBack = TexMan.CheckForTexture("DRLPBACK");
		_vignette = TexMan.CheckForTexture("sprites/hud/vignette.png");
		_infiniteText = TexMan.CheckForTexture("DRINFTXT");
		_damageIndicator = TexMan.CheckForTexture("DRDMGIND");
		_grazeIndicator = TexMan.CheckForTexture("DRGRZIND");
		
		controlIcons[DELTA_CONTROLICON_MOUSE1]	= TexMan.CheckForTexture("DRMSELCL");
		controlIcons[DELTA_CONTROLICON_MOUSE2]	= TexMan.CheckForTexture("DRMSERCL");
		controlIcons[DELTA_CONTROLICON_MOUSE3]	= TexMan.CheckForTexture("DRMSEMCL");
		controlIcons[DELTA_CONTROLICON_MOUSE4]	= TexMan.CheckForTexture("DRMSEBT4");
		controlIcons[DELTA_CONTROLICON_MOUSE5]	= TexMan.CheckForTexture("DRMSEBT5");
		controlIcons[DELTA_CONTROLICON_MOUSE6]	= TexMan.CheckForTexture("DRMSEBT6");
		controlIcons[DELTA_CONTROLICON_MOUSE7]	= TexMan.CheckForTexture("DRMSEBT7");
		controlIcons[DELTA_CONTROLICON_MOUSE8]	= TexMan.CheckForTexture("DRMSEBT8");
		
		ammoIcons[DELTA_AMMOICON_BULLETS]	= TexMan.CheckForTexture("DRAMBULL");
		ammoIcons[DELTA_AMMOICON_SHELLS]	= TexMan.CheckForTexture("DRAMSHEL");
		ammoIcons[DELTA_AMMOICON_ROCKETS]	= TexMan.CheckForTexture("DRAMROCK");
		ammoIcons[DELTA_AMMOICON_PLASMA]	= TexMan.CheckForTexture("DRAMPLAS");
		ammoIcons[DELTA_AMMOICON_FUEL]		= TexMan.CheckForTexture("DRAMFUEL");
		
		_tpInterp = DynamicValueInterpolator.Create(0, 0.25, 1, 30);
	}
	
	override void Tick()
	{
		Super.Tick();
		
		if (!CPlayer.mo)
			return;
		
		bool infiniteAmmo = sv_infiniteAmmo || (CPlayer.mo.FindInventory('PowerInfiniteAmmo', true) != null);
		DeltaPlayer ply = DeltaPlayer(CPlayer.mo);
		
		if (!ply)
			return;
		
		_oldTp = _tpInterp.GetValue();
		_tpInterp.Update(infiniteAmmo ? ply.maxTensionPoints : ply.tensionPoints);
		
		for (int i = 0; i < damageIndicators.Size(); i++)
		{
			if (damageIndicators[i].timer)
				damageIndicators[i].timer--;
		}
		
		for (int i = 0; i < grazeIndicators.Size(); i++)
		{
			if (grazeIndicators[i].timer)
				grazeIndicators[i].timer--;
		}
		
		_oldAngle = _currAngle;
		_currAngle = ply.Angle;
		
		_oldPos = _currPos;
		_currPos = ply.Pos;
	}
	
	override void Draw(int state, double ticFrac)
	{
		Super.Draw(state, ticFrac);
		
		if (state == HUD_None || !delta_showHud)
			return;
		
		_universalScale = (1, (hud_aspectScale ? (1/1.2) : 1));
		_vBorder = 30 * _universalScale.y;
		
		if (CPlayer.Health <= 40 && delta_lowHealthVignette)
		{
			double alpha = 1 - CPlayer.Health / 40.;
			Screen.DrawTexture(_vignette, false, 0, 0, DTA_Fullscreen, true,
				DTA_FullScreenScale, FSMode_ScaleToScreen, DTA_Alpha, alpha,
				DTA_Color, CPlayer.mo.GetPainFlash());
		}
		
		BeginHUD(1, false);
		DrawDamageIndicators(ticFrac);
		DrawGrazeIndicators(ticFrac);
		
		if (CPlayer.Health > 0)
		{
			DrawLeftPanel(sv_infiniteAmmo || (CPlayer.mo.FindInventory('PowerInfiniteAmmo', true) != null), ticFrac);
			DrawRightPanel(sv_infiniteAmmo || (CPlayer.mo.FindInventory('PowerInfiniteAmmo', true) != null));
		}
	}
	
	protected void DrawDamageIndicators(double ticFrac)
	{
		for (int i = 0; i < damageIndicators.Size(); i++)
		{
			/*
			DrawString(_consoleFont, "Indicator " .. i+1
				.. ": Timer " .. damageIndicators[i].timer .. ", Pos " ..
				damageIndicators[i].sourcePos, (0, i*12 + 6));
			*/
			
			if (damageIndicators[i].timer <= 0)
				continue;
			
			Vector3 targetPos = damageIndicators[i].sourcePos;
			let player = CPlayer.mo;
			Vector3 playerPos = DeltaMath.Vector3Lerp(_oldPos, _currPos, ticFrac);
			float refAng = DeltaMath.Lerp(_oldAngle, _currAngle, ticFrac);
			Vector3 diff = level.Vec3Diff(playerPos, targetPos);
			float ang = player.DeltaAngle(refAng, VectorAngle(diff.x, diff.y));
			float alpha = min(1, (damageIndicators[i].timer - ticFrac) / DAMAGE_INDICATOR_FADE_TIME);
			float distance = 90;
			Vector2 hudScale = GetHUDScale() / 2;
			hudScale.x *= _universalScale.x;
			hudScale.y *= _universalScale.y;
			
			DrawTextureRotated (
				_damageIndicator,
				(distance * sin(-ang) / hudScale.x, -distance * cos(ang) / hudScale.y),
				DI_SCREEN_CENTER | DI_ITEM_OFFSETS,
				ang,
				alpha,
				hudScale,
				col: 0xff000000 | player.GetPainFlash()
			);
			//DrawString(_consoleFont, "Angle: " .. ang, (0, 0));
		}
	}
	
	protected void DrawGrazeIndicators(double ticFrac)
	{
		for (int i = 0; i < grazeIndicators.Size(); i++)
		{
			if (grazeIndicators[i].timer <= 0 || !grazeIndicators[i].grazing)
				continue;
			
			Vector3 targetPos = grazeIndicators[i].sourcePos;
			let player = CPlayer.mo;
			Vector3 playerPos = DeltaMath.Vector3Lerp(_oldPos, _currPos, ticFrac);
			float refAng = DeltaMath.Lerp(_oldAngle, _currAngle, ticFrac);
			Vector3 diff = level.Vec3Diff(playerPos, targetPos);
			float ang = player.DeltaAngle(refAng, VectorAngle(diff.x, diff.y));
			float alpha = min(1, (grazeIndicators[i].timer - ticFrac) / GRAZE_INDICATOR_TIME);
			float distance = 120;
			Vector2 hudScale = GetHUDScale() / 2;
			hudScale.x *= _universalScale.x;
			hudScale.y *= _universalScale.y;
			
			DrawTextureRotated (
				_grazeIndicator,
				(distance * sin(-ang) / hudScale.x, -distance * cos(ang) / hudScale.y),
				DI_SCREEN_CENTER | DI_ITEM_OFFSETS,
				ang,
				alpha,
				hudScale,
				col: 0xffffffff
			);
		}
	}
	
	protected float GetHealthPerc()
	{
		return CPlayer.mo.GetMaxHealth() == 0 ? 0 : min(2, CPlayer.Health / float(CPlayer.mo.GetMaxHealth()));
	}
	
	protected TextureID GetMainBindingIcon(string cmd)
	{
		int k = Bindings.GetKeysForCommand(cmd);
		
		// not a mouse button!
		if (k < 0x100 || k > 0x108)
			return null;
		
		k -= 0xff;
		return controlIcons[k];
	}
	
	protected void DisplayBinding(string cmd, Vector2 pos, int flags, Vector2 scale)
	{
		let tex = GetMainBindingIcon(cmd);
		
		if (tex)
			DrawTexture(tex, pos, flags, scale: scale);
		else
		{
			int k = Bindings.GetKeysForCommand(cmd);
			string keys = Keybindings.NameKeys(k, 0);
			double newY = pos.y;
			
			if (flags & DI_ITEM_VCENTER)
				newY -= _consoleFont.mFont.GetHeight() / 2;
			
			DrawString(_consoleFont, keys, (pos.x, newY), flags, scale: scale);
		}
	}
	
	protected void DrawLeftPanel(bool infiniteAmmo, double ticFrac)
	{
		double yMultiplier = _universalScale.y;
		double panelXSpacing = 4;
		double panelYSpacing = 4 * yMultiplier;
		double curY = -_vBorder;
		double barWidth = 144;
		double barHeight = 16 * yMultiplier;
		double labelXOffset = 50;
		double barXOffset = 14 + labelXOffset + panelXSpacing;
		double panelY = curY - barHeight * 2 - panelYSpacing * 4 - (3 * yMultiplier);
		
		DrawTexture(_leftPanelBack, (_hBorder, panelY), DI_SCREEN_LEFT_BOTTOM | DI_ITEM_LEFT_TOP, scale: _universalScale);
		
		double smallFontHeight = _drHudFont.mFont.GetGlyphHeight("0") * yMultiplier;
		double halfDifference = (barHeight * yMultiplier - smallFontHeight) / 2;
		double textYOffset = halfDifference + 0.5;
		
		DeltaPlayer ply = DeltaPlayer(CPlayer.mo);
		
		if (!ply)
			return;
		
		TextureID currentFace = GetMugshot(4, Mugshot.DISABLEOUCH);
		
		int temp, panelYSize, faceYSize;
		[temp, panelYSize] = TexMan.GetSize(_leftPanelBack);
		[temp, faceYSize] = TexMan.GetSize(currentFace);
		
		DrawTexture(currentFace, (_hBorder + panelXSpacing*2, panelY + panelYSize*yMultiplier - 46*yMultiplier),
			DI_SCREEN_LEFT_BOTTOM | DI_ITEM_LEFT_TOP, scale: _universalScale);
		
		if (!deathmatch)
			DrawKeys(_hBorder + panelXSpacing + barXOffset, curY - 1*yMultiplier);
		else
			DrawDeathmatch();
		
		/// ---- DRAWING TENSION POINTS ----
		// draw TP timer and bar
		curY -= 4*yMultiplier + panelYSpacing;
		
		double tpTimer = float(ply.tensionDrainTimer) / ply.DRAIN_TIMER_START;
		Fill(0xffffffff, _hBorder + panelXSpacing + barXOffset, curY, tpTimer * barWidth, 3*yMultiplier, DI_SCREEN_LEFT_BOTTOM);
		
		curY -= 3*yMultiplier + barHeight;
		
		double tp = infiniteAmmo ? ply.maxTensionPoints : ply.tensionPoints;
		double maxTp = ply.maxTensionPoints;
		
		if (ply.ticLastGrazed >= 0)
		{
			int timePassed = level.Time - ply.ticLastGrazed;
			int alpha = 255 * (1 - (timePassed / 5.));
			
			DrawTexture(_tpHighlight, (_hBorder + panelXSpacing + labelXOffset - 1, curY - yMultiplier),
				DI_SCREEN_LEFT_BOTTOM | DI_ITEM_LEFT_TOP, scale: _universalScale,
				col: Color(alpha, 255, 255, 255));
		}
		
		Fill(Color(255, 255, 0, 0), _hBorder + panelXSpacing + barXOffset, curY,
			DeltaMath.Lerp(_oldTp, _tpInterp.GetValue(), ticFrac) / maxTp * barWidth,
			barHeight, DI_SCREEN_LEFT_BOTTOM);
		Fill(Color(255, 255, 160, 64), _hBorder + panelXSpacing + barXOffset, curY,
			tp / maxTp * barWidth, barHeight, DI_SCREEN_LEFT_BOTTOM);
		
		if (tp >= 1 && tp <= maxTp - 1)
			Fill(Color(255, 255, 255, 255), _hBorder + panelXSpacing + barXOffset + barWidth * (tp / maxTp) - 1, curY, 1, barHeight, DI_SCREEN_LEFT_BOTTOM);
		
		// draw TP text
		if (!infiniteAmmo)
		{
			if (tp < maxTp)
				DrawString(_drHudFont, String.Format("%d", tp * 100 / maxTp),
					(_hBorder + barWidth + barXOffset + 1, curY + textYOffset/2),
					DI_SCREEN_LEFT_BOTTOM | DI_TEXT_ALIGN_RIGHT,
					scale: _universalScale * 2);
			else
				DrawTexture(_tpMaxText,
					(_hBorder + barWidth + barXOffset, curY + panelYSpacing + barHeight/2 + 1),
					DI_SCREEN_LEFT_BOTTOM | DI_ITEM_RIGHT, scale: _universalScale * 2);
		}
		else
			DrawTexture(_infiniteText,
				(_hBorder + barWidth + barXOffset + 1, curY + panelYSpacing + barHeight/2),
				DI_SCREEN_LEFT_BOTTOM | DI_ITEM_RIGHT, scale: _universalScale * 1.25);
		
		// ================
		//  DRAWING HEALTH
		// ================
		curY -= panelYSpacing + barHeight;
		Fill(ply.GetCharacterColor(), _hBorder + panelXSpacing + barXOffset,
			curY, min(1, GetHealthPerc()) * barWidth, barHeight, DI_SCREEN_LEFT_BOTTOM);
		
		if (GetHealthPerc() > 1)
			Fill(ply.GetOverhealColor(), _hBorder + panelXSpacing + barXOffset,
				curY, min(1, GetHealthPerc() - 1) * barWidth, barHeight, DI_SCREEN_LEFT_BOTTOM);
		
		string format = GetHealthPerc() <= 0.33 ? "\c[DeltaLowHealth]%s" : "%s";
		string maxHp = String.Format(format, "" .. ply.GetMaxHealth());
		int maxHpWidth = _drHudFont.mFont.StringWidth(maxHp);
		int slashWidth = _drHudFont.mFont.GetCharWidth("/");
		DrawString(_drHudFont, String.Format(format, "" .. CPlayer.Health),
			(_hBorder + barWidth + barXOffset - maxHpWidth - (2*slashWidth), curY + textYOffset/2),
			DI_SCREEN_LEFT_BOTTOM | DI_TEXT_ALIGN_RIGHT, scale: _universalScale * 2);
		DrawString(_drHudFont, String.Format(format, "/"),
			(_hBorder + barWidth + barXOffset - maxHpWidth - slashWidth, curY + textYOffset/2),
			DI_SCREEN_LEFT_BOTTOM | DI_TEXT_ALIGN_RIGHT, scale: _universalScale);
		DrawString(_drHudFont, maxHp,
			(_hBorder + barWidth + barXOffset + 1, curY + textYOffset/2),
			DI_SCREEN_LEFT_BOTTOM | DI_TEXT_ALIGN_RIGHT, scale: _universalScale * 2);
		DrawTexture(_hpText,
			(_hBorder + labelXOffset + panelXSpacing, curY + panelYSpacing + barHeight/2),
			DI_SCREEN_LEFT_BOTTOM | DI_ITEM_LEFT, scale: (1, yMultiplier),
			col: GetHealthPerc() <= 0.33 ? 0xffffff00 : 0xffffffff);
		
		// =============================
		//  DRAWING OFFHAND INFORMATION
		// =============================
		double offhandPanelHeight = 36 * yMultiplier;
		bool canUse = ply.CanUseOffhand();
		curY -= offhandPanelHeight + panelYSpacing*2;
		Fill(0x80000000, _hBorder, curY, panelXSpacing*3 + 48, offhandPanelHeight);
		// control icons should all be 16px x 16px (or equivalent if scaled)
		DisplayBinding("+user1", (_hBorder + panelXSpacing, curY + offhandPanelHeight/2),
			DI_SCREEN_LEFT_BOTTOM | DI_ITEM_LEFT | DI_ITEM_VCENTER, _universalScale);
		// offhand icons should all be 32px x 32px (or equivalent if scaled)
		DrawTexture(ply.GetOffhandIconID(), (_hBorder + panelXSpacing*2 + 16, curY + 2*yMultiplier),
			DI_SCREEN_LEFT_BOTTOM | DI_ITEM_LEFT_TOP, scale: _universalScale,
			col: canUse ? (ply.GetIsUsingOffhand() ? Color(255, 255, 160, 64) : 0xffffffff) : 0x80606060);
	}
	
	protected void DrawRightPanel(bool infiniteAmmo)
	{
		let weap = CPlayer.ReadyWeapon;
		
		if (weap == null || weap.AmmoType1 == null)
			return;
		
		double yMultiplier = _universalScale.y;
		double widgetWidth = 40 + 22, widgetHeight = 28 * yMultiplier;
		int ammo1 = CPlayer.mo.FindInventory(CPlayer.ReadyWeapon.AmmoType1).Amount;
		let ammoType1 = CPlayer.ReadyWeapon.AmmoType1;
		int ammoIcon = DELTA_AMMOICON_NONE;
		
		if (ammoType1 == "Clip")
			ammoIcon = DELTA_AMMOICON_BULLETS;
		else if (ammoType1 == "Shell")
			ammoIcon = DELTA_AMMOICON_SHELLS;
		else if (ammoType1 == "RocketAmmo")
			ammoIcon = DELTA_AMMOICON_ROCKETS;
		else if (ammoType1 == "Cell")
			ammoIcon = DELTA_AMMOICON_PLASMA;
		else if (ammoType1 == "ID24Fuel")
			ammoIcon = DELTA_AMMOICON_FUEL;
		
		Fill(Color(128, 0, 0, 0), -_hBorder - widgetWidth,
			-_vBorder - widgetHeight + (4 * yMultiplier), widgetWidth,
			widgetHeight, DI_SCREEN_RIGHT_BOTTOM);
		
		if (ammoIcon != DELTA_AMMOICON_NONE)
			DrawTexture(ammoIcons[ammoIcon], (-_hBorder - widgetWidth + 12, -_vBorder - widgetHeight/2 + 4),
				DI_ITEM_CENTER | DI_SCREEN_RIGHT_BOTTOM, box: (16, 16));
		
		if (!infiniteAmmo)
			DrawString(_drHudFont, String.Format("%d", ammo1),
				(-_hBorder - 4, -_vBorder - (18 * yMultiplier)),
				DI_SCREEN_RIGHT_BOTTOM | DI_TEXT_ALIGN_RIGHT, scale: 3 * _universalScale);
		else
			DrawTexture(_infiniteText, (-_hBorder - 4, -_vBorder - (10 * yMultiplier)),
				DI_SCREEN_RIGHT_BOTTOM | DI_ITEM_RIGHT | DI_ITEM_VCENTER, box: (28, 16), scale: _universalScale * 15/8);
	}
	
	protected void DrawKeys(double x, double y)
	{
		int count = Key.GetKeyTypeCount();
		double newX = x;
		Key inv;
		
		for (int i = 0; i <= count - 1; i++)
		{
			if (inv = Key(CPlayer.mo.FindInventory(Key.GetKeyType(i))))
			{
				TextureID icon;
				
				if (inv.SpawnState && inv.SpawnState.sprite != 0)
				{
					let state = inv.SpawnState;
					
					if (state != null)
						icon = state.GetSpriteTexture(0);
					else
						icon.SetNull();
				}
				
				if (icon.IsNull())
					icon = inv.Icon;
				
				if (icon.IsValid())
				{
					DrawTexture(icon, (newX, y), DI_SCREEN_LEFT_BOTTOM
						| DI_ITEM_LEFT_TOP, box: 8 * _universalScale, scale: _universalScale);
					newX += 10;
				}
			}
		}
	}
	
	protected void DrawDeathmatch()
	{
		
	}
	
	void CreateDamageIndicator(Actor source)
	{
		if (!source)
			return;
		
		int smallestTimer = -1;
		int smallestTimerIndex;
		
		for (int i = 0; i < grazeIndicators.Size(); i++)
		{
			if (!grazeIndicators[i].grazing || !grazeIndicators[i].grazing.target
				|| grazeIndicators[i].grazing.target != source) continue;
			
			grazeIndicators[i].timer = 0;
		}
		
		for (int i = 0; i < damageIndicators.Size(); i++)
		{
			if (damageIndicators[i].timer <= 0)
			{
				damageIndicators[i].timer = DAMAGE_INDICATOR_TIME;
				damageIndicators[i].sourcePos = source.Pos;
				return;
			}
			
			if (smallestTimer > 0 && damageIndicators[i].timer > smallestTimer)
				continue;
			
			smallestTimer = damageIndicators[i].timer;
			smallestTimerIndex = i;
		}
		
		damageIndicators[smallestTimerIndex].timer = DAMAGE_INDICATOR_TIME;
		damageIndicators[smallestTimerIndex].sourcePos = source.Pos;
	}
	
	void CreateGrazeIndicator(Actor source)
	{
		if (!source)
			return;
		
		int smallestTimer = -1;
		int smallestTimerIndex;
		
		for (int i = 0; i < grazeIndicators.Size(); i++)
		{
			if (grazeIndicators[i].timer <= 0 || !grazeIndicators[i].grazing
				|| grazeIndicators[i].grazing == source)
			{
				grazeIndicators[i].timer = GRAZE_INDICATOR_TIME;
				grazeIndicators[i].grazing = source;
				grazeIndicators[i].sourcePos = source.Pos;
				return;
			}
			
			if (smallestTimer > 0 && grazeIndicators[i].timer > smallestTimer)
				continue;
			
			smallestTimer = grazeIndicators[i].timer;
			smallestTimerIndex = i;
		}
		
		grazeIndicators[smallestTimerIndex].timer = GRAZE_INDICATOR_TIME;
		grazeIndicators[smallestTimerIndex].grazing = source;
		grazeIndicators[smallestTimerIndex].sourcePos = source.Pos;
	}
}

class DeltaAltHUD : AltHUD
{
	override void DrawInGame(PlayerInfo CPlayer)
	{
		// kept blank so we don't draw an alt hud at all
	}
}