struct DamageIndicatorInfo
{
	int timer;
	Vector3 sourcePos;
}

struct GrazeIndicatorInfo
{
	int timer;
	Actor grazing;
	Vector3 sourcePos;
}

class DeltaHud : BaseStatusBar
{
	private double _hBorder, _vBorder;
	private double _oldAngle, _currAngle;
	private Vector3 _oldPos, _currPos;
	private Vector2 _universalScale;
	private HUDFont _consoleFont, _drHudFont;
	private TextureID _hpText, _tpText, _tpMaxText, _tpHighlight,
		_leftPanelBack, _vignette, _infiniteText, _damageIndicator,
		_grazeIndicator, _defaultCrosshair, _offhandCrosshair,
		_coopPanelBack, _deathmatchPanelBack, _deathmatchCurrentPlayer;
	private double _oldTp;
	DynamicValueInterpolator _tpInterp;
	
	private DamageIndicatorInfo[10] damageIndicators;
	private GrazeIndicatorInfo[10] grazeIndicators;
	private Array<class<Ammo> > ammos;
	
	const DAMAGE_INDICATOR_TIME = floor(TICRATE * 2);
	const DAMAGE_INDICATOR_FADE_TIME = floor(TICRATE * 0.75);
	const GRAZE_INDICATOR_TIME = floor(TICRATE * 0.25);
	const WEAPON_SLOTS_WRAPAROUND = 9;
	
	enum CONTROL_ICON_IDS
	{
		DELTA_CONTROLICON_TEXT = 0xff, // use text for this key and keys below it!
		
		DELTA_CONTROLICON_MOUSE1, DELTA_CONTROLICON_MOUSE2, DELTA_CONTROLICON_MOUSE3,
		DELTA_CONTROLICON_MOUSE4, DELTA_CONTROLICON_MOUSE5, DELTA_CONTROLICON_MOUSE6,
		DELTA_CONTROLICON_MOUSE7, DELTA_CONTROLICON_MOUSE8,
		
		DELTA_CONTROLICON_MAX
	}
	
	Map<int, TextureID> controlIcons;
	Map<name, TextureID> ammoIcons;
	
	override void Init()
	{
		Super.Init();
		
		_drHudFont = HUDFont.Create("DRHUDFONT");
		_consoleFont = HUDFont.Create("DRCONFONT");
		
		_hpText 					= TexMan.CheckForTexture("DRHPTEXT");
		_tpText 					= TexMan.CheckForTexture("DRTPTEXT");
		_tpMaxText 					= TexMan.CheckForTexture("DRHUDMAX");
		_tpHighlight 				= TexMan.CheckForTexture("DRTPHLGT");
		_leftPanelBack 				= TexMan.CheckForTexture("DRLPBACK");
		_vignette 					= TexMan.CheckForTexture("sprites/hud/vignette.png");
		_infiniteText 				= TexMan.CheckForTexture("DRINFTXT");
		_damageIndicator 			= TexMan.CheckForTexture("DRDMGIND");
		_grazeIndicator 			= TexMan.CheckForTexture("DRGRZIND");
		_defaultCrosshair 			= TexMan.CheckForTexture("DRMTYRET");
		_offhandCrosshair 			= TexMan.CheckForTexture("DROFHRET");
		_coopPanelBack 				= TexMan.CheckForTexture("COOPBACK");
		_deathmatchPanelBack 		= TexMan.CheckForTexture("DTHMBACK");
		_deathmatchCurrentPlayer 	= TexMan.CheckForTexture("DTHMCPLY");
		
		controlIcons.Insert(DELTA_CONTROLICON_MOUSE1, TexMan.CheckForTexture("DRMSELCL"));
		controlIcons.Insert(DELTA_CONTROLICON_MOUSE2, TexMan.CheckForTexture("DRMSERCL"));
		controlIcons.Insert(DELTA_CONTROLICON_MOUSE3, TexMan.CheckForTexture("DRMSEMCL"));
		controlIcons.Insert(DELTA_CONTROLICON_MOUSE4, TexMan.CheckForTexture("DRMSEBT4"));
		controlIcons.Insert(DELTA_CONTROLICON_MOUSE5, TexMan.CheckForTexture("DRMSEBT5"));
		controlIcons.Insert(DELTA_CONTROLICON_MOUSE6, TexMan.CheckForTexture("DRMSEBT6"));
		controlIcons.Insert(DELTA_CONTROLICON_MOUSE7, TexMan.CheckForTexture("DRMSEBT7"));
		controlIcons.Insert(DELTA_CONTROLICON_MOUSE8, TexMan.CheckForTexture("DRMSEBT8"));
		
		ammoIcons.Insert('Clip', 		TexMan.CheckForTexture("DRAMBULL"));
		ammoIcons.Insert('Shell', 		TexMan.CheckForTexture("DRAMSHEL"));
		ammoIcons.Insert('RocketAmmo', 	TexMan.CheckForTexture("DRAMROCK"));
		ammoIcons.Insert('Cell', 		TexMan.CheckForTexture("DRAMPLAS"));
		ammoIcons.Insert('ID24Fuel', 	TexMan.CheckForTexture("DRAMFUEL"));
		
		_tpInterp = DynamicValueInterpolator.Create(0, 0.25, 1, 30);
	}
	
	override void Tick()
	{
		Super.Tick();
		
		if (!CPlayer.mo)
			return;
		
		bool infiniteAmmo = sv_infiniteAmmo || (CPlayer.mo.FindInventory('PowerInfiniteAmmo', true) != null);
		DeltaPlayer ply = DeltaPlayer(CPlayer.mo);
		
		if (!ply)
			return;
		
		_oldTp = _tpInterp.GetValue();
		_tpInterp.Update(infiniteAmmo ? ply.maxTensionPoints : ply.tensionPoints);
		
		for (int i = 0; i < damageIndicators.Size(); i++)
		{
			if (damageIndicators[i].timer)
				damageIndicators[i].timer--;
		}
		
		for (int i = 0; i < grazeIndicators.Size(); i++)
		{
			if (grazeIndicators[i].timer)
				grazeIndicators[i].timer--;
		}
		
		_oldAngle = _currAngle;
		_currAngle = ply.Angle;
		_oldPos = _currPos;
		_currPos = ply.Pos;
		
		let weaps = CPlayer.weapons;
		if (!weaps)
			return;
		
		for (int i = 1;; i++)
		{
			int weapCount = weaps.SlotSize(i);
			
			if (i > WEAPON_SLOTS_WRAPAROUND)
			{
				i = -1;
				continue;
			}
			if (i == 0)
				break;
			
			if (!weapCount)
				continue;
			
			for (int j = 0; j < weapCount; j++)
			{
				if (!CPlayer.mo.CountInv(weaps.GetWeapon(i, j)))
					continue;
				
				Weapon inv = Weapon(CPlayer.mo.FindInventory(weaps.GetWeapon(i, j)));
				
				if (!inv)
					continue;
				if (!inv.AmmoType1)
					continue;
				if (ammos.Find(inv.AmmoType1) != ammos.Size())
					continue;
				
				ammos.Push(inv.AmmoType1);
			}
		}
	}
	
	override void Draw(int state, double ticFrac)
	{
		Super.Draw(state, ticFrac);
		
		if (state == HUD_None || !cl_delta_showHud)
			return;
		
		_universalScale = GetHudScale();
		_universalScale = (2 / _universalScale.x, 2 / _universalScale.y);
		
		_hBorder = 30 * _universalScale.x;
		_vBorder = 30 * _universalScale.y;
		
		if (CPlayer.Health <= 40 && cl_delta_lowHealthVignette && !automapActive)
		{
			double alpha = 1 - CPlayer.Health / 40.;
			Screen.DrawTexture(_vignette, false, 0, 0, DTA_Fullscreen, true,
				DTA_FullScreenScale, FSMode_ScaleToScreen, DTA_Alpha, alpha,
				DTA_Color, CPlayer.mo.GetPainFlash());
		}
		
		BeginHUD(1, false);
		DrawDamageIndicators(ticFrac);
		DrawGrazeIndicators(ticFrac);
		
		if (deathmatch)
			DrawDeathmatch();
		else if (multiplayer)
			DrawCoop();
		
		if (CPlayer.Health > 0)
		{
			DrawLeftPanel(sv_infiniteAmmo || (CPlayer.mo.FindInventory('PowerInfiniteAmmo', true) != null), ticFrac);
			DrawRightPanel(sv_infiniteAmmo || (CPlayer.mo.FindInventory('PowerInfiniteAmmo', true) != null));
			DrawReticle();
		}
		else
		{
			DrawDeathStuff();
		}
	}
	
	protected void DrawDamageIndicators(double ticFrac)
	{
		float distance = 100;
		Vector2 indicatorScale = (1.5, 1.5);
		
		for (int i = 0; i < damageIndicators.Size(); i++)
		{
			/*
			DrawString(_consoleFont, "Indicator " .. i+1
				.. ": Timer " .. damageIndicators[i].timer .. ", Pos " ..
				damageIndicators[i].sourcePos, (0, i*12 + 6));
			*/
			
			if (damageIndicators[i].timer <= 0)
				continue;
			
			Vector3 targetPos = damageIndicators[i].sourcePos;
			let player = CPlayer.mo;
			Vector3 playerPos = DeltaMath.Vector3Lerp(_oldPos, _currPos, ticFrac);
			float refAng = DeltaMath.Lerp(_oldAngle, _currAngle, ticFrac);
			Vector3 diff = level.Vec3Diff(playerPos, targetPos);
			float ang = player.DeltaAngle(refAng, VectorAngle(diff.x, diff.y));
			float alpha = min(1, (damageIndicators[i].timer - ticFrac) / DAMAGE_INDICATOR_FADE_TIME);
			
			DrawTextureRotated (
				_damageIndicator,
				(distance * sin(-ang) / indicatorScale.x, -distance * cos(ang) / indicatorScale.y),
				DI_SCREEN_CENTER | DI_ITEM_OFFSETS,
				ang,
				alpha,
				indicatorScale,
				col: 0xff000000 | player.GetPainFlash()
			);
			//DrawString(_consoleFont, "Angle: " .. ang, (0, 0));
		}
	}
	
	protected void DrawGrazeIndicators(double ticFrac)
	{
		float distance = 80;
		Vector2 indicatorScale = (1.5, 1.5);
		
		for (int i = 0; i < grazeIndicators.Size(); i++)
		{
			if (grazeIndicators[i].timer <= 0 || !grazeIndicators[i].grazing)
				continue;
			
			Vector3 targetPos = grazeIndicators[i].sourcePos;
			let player = CPlayer.mo;
			Vector3 playerPos = DeltaMath.Vector3Lerp(_oldPos, _currPos, ticFrac);
			float refAng = DeltaMath.Lerp(_oldAngle, _currAngle, ticFrac);
			Vector3 diff = level.Vec3Diff(playerPos, targetPos);
			float ang = player.DeltaAngle(refAng, VectorAngle(diff.x, diff.y));
			float alpha = min(1, (grazeIndicators[i].timer - ticFrac) / GRAZE_INDICATOR_TIME);
			
			DrawTextureRotated(
				_grazeIndicator,
				(distance * sin(-ang) / indicatorScale.x, -distance * cos(ang) / indicatorScale.y),
				DI_SCREEN_CENTER | DI_ITEM_OFFSETS,
				ang,
				alpha,
				indicatorScale,
				col: 0xffffffff
			);
		}
	}
	
	protected void DrawCoop()
	{
		double curX = _hBorder, curY = _vBorder;
		
		for (int i = 0; i < players.Size(); i++)
		{
			if (!players[i].mo || players[i] == CPlayer)
				continue;
			if (!playerInGame[i])
				continue;
			if (!(players[i].mo is "DeltaPlayer"))
				continue;
			
			DrawMultiplayerHealth(DeltaPlayer(players[i].mo), (curX, curY));
			curY += 24 * _universalScale.y;
		}
	}
	
	protected void DrawDeathmatch()
	{
		if (!CPlayer.mo || !(CPlayer.mo is "DeltaPlayer"))
			return;
		
		/// ---------------------------
		/// DRAWING TEAMMATE HEALTHBARS
		/// ---------------------------
		double curX = _hBorder, curY = _vBorder;
		let ply = DeltaPlayer(CPlayer.mo);
		Array<int> teamsFound;
		
		if (teamplay)
		{
			for (int i = 0; i < players.Size(); i++)
			{
				if (!players[i].mo)
					continue;
				if (!playerInGame[i])
					continue;
				if (!(players[i].mo is "DeltaPlayer"))
					continue;
				
				if (teamsFound.Find(players[i].GetTeam()) == teamsFound.Size())
					teamsFound.Push(players[i].GetTeam());
				
				if (players[i] == CPlayer)
					continue;
				if (!CPlayer.mo.IsTeammate(players[i].mo))
					continue;
				
				DrawMultiplayerHealth(DeltaPlayer(players[i].mo), (curX, curY));
				curY += 24 * _universalScale.y;
			}
		}
		
		DrawTexture(_deathmatchPanelBack, (0, -_vBorder),
			DI_SCREEN_CENTER_BOTTOM | DI_ITEM_HCENTER | DI_ITEM_BOTTOM,
			scale: _universalScale*2);
		
		/// ------------
		/// DRAWING TIME
		/// ------------
		if (timelimit)
		{
			double timeTics = ceil(timelimit * 60 * TICRATE) - level.maptime;
			int timeHours = timeTics / TICRATE / 3600;
			timeTics -= timeHours * TICRATE * 3600;
			int timeMinutes = timeTics / TICRATE / 60;
			timeTics -= timeMinutes * TICRATE * 60;
			int timeSeconds = ceil(timeTics / TICRATE);
			
			if (timeMinutes == 60)
			{
				timeMinutes = 0;
				timeHours++;
			}
			
			if (timeSeconds == 60)
			{
				timeSeconds = 0;
				timeMinutes++;
			}
			
			double fontHeight = _consoleFont.mFont.GetHeight();
			String timeStr;
			
			if (timeHours)
				timeStr = String.Format("%u", timeHours);
			if (timeHours || timeMinutes)
				timeStr = String.Format(timeHours ? "%s:%02u" : "%s%u", timeStr, timeMinutes);
			if (!timeHours)
				timeStr = String.Format("%s:%02u", timeStr, timeSeconds);
			
			DrawString(_consoleFont, timeStr,
				(-75*_universalScale.x, -_vBorder - (14+fontHeight)*_universalScale.y),
				DI_SCREEN_CENTER_BOTTOM | DI_TEXT_ALIGN_CENTER, scale: _universalScale);
		}
		else
			DrawTexture(_infiniteText, (-72*_universalScale.x, -_vBorder - 14*_universalScale.y),
				DI_SCREEN_CENTER_BOTTOM | DI_ITEM_CENTER_BOTTOM, scale: _universalScale*2);
		
		/// -------------
		/// DRAWING FRAGS
		/// -------------
		let leaderFrags = -500;
		let leaderIndex = 0;
		Color barColor;
		TextureID characterIcon;
		double fontHeight = _drHudFont.mFont.GetHeight();
		string nameShown = "";
		bool leaderIsUs = false;
		
		// Drawing leader bar (may be us)
		if (teamplay)
		{
			for (uint i = 0; i < uint(teams.Size()); i++)
			{
				if (teamsFound.Find(i) == teamsFound.Size())
					continue;
				
				int curTeamFrags = GetTeamFrags(i);
				
				if (curTeamFrags <= leaderFrags)
					continue;
				
				leaderFrags = curTeamFrags;
				leaderIndex = i;
				leaderIsUs = CPlayer.GetTeam() == i;
				nameShown = teams[i].mName;
				barColor = teams[i].GetPlayerColor();
			}
		}
		else
		{
			for (int i = 0; i < players.Size(); i++)
			{
				if (!playerInGame[i])
					continue;
				if (!(players[i].mo is "DeltaPlayer"))
					continue;
				
				let deltaPly = DeltaPlayer(players[i].mo);
				int curPlyFrags = players[i].fragCount;
				
				if (curPlyFrags < leaderFrags)
					continue;
				if (curPlyFrags == leaderFrags && players[i] != CPlayer && leaderFrags == 0)
					continue;
				
				leaderFrags = curPlyFrags;
				leaderIndex = i;
				nameShown = players[i].GetUserName();
				characterIcon = deltaPly.GetCharacterIconId();
				barColor = deltaPly.GetCharacterColor();
				leaderIsUs = CPlayer == players[i];
			}
		}
		
		barColor |= 0xff000000;
		nameShown.Truncate(16);
		Fill(barColor, -32*_universalScale.x, -_vBorder - 36*_universalScale.y,
			min(1., (max(0., leaderFrags) / max(1., fraglimit))) * 132 * _universalScale.x, -20 * _universalScale.y,
			DI_SCREEN_CENTER_BOTTOM);
		DrawTexture(characterIcon, (-33*_universalScale.x, -_vBorder - 36.5*_universalScale.y),
			DI_SCREEN_CENTER_BOTTOM | DI_ITEM_LEFT_BOTTOM,
			box: (25*_universalScale.x, 20*_universalScale.y), scale: _universalScale);
		DrawString(_drHudFont, "" .. leaderFrags,
			(98*_universalScale.x, -_vBorder - (fontHeight+43.5)*_universalScale.y),
			DI_SCREEN_CENTER_BOTTOM | DI_TEXT_ALIGN_RIGHT, scale: _universalScale*3);
		DrawString(_consoleFont, nameShown,
			((teamplay ? -33 : -12)*_universalScale.x, -_vBorder - (fontHeight/2+45.5)*_universalScale.y),
			DI_SCREEN_CENTER_BOTTOM | DI_TEXT_ALIGN_LEFT, scale: _universalScale/2);
		
		// Bottom bar (second place if we're leader, us otherwise)
		let bottomFrags = -500, bottomIndex = 0;
		barColor = 0x0;
		characterIcon = null;
		
		if (leaderIsUs)
		{
			if (teamplay)
			{
				for (int i = 0; i < teams.Size(); i++)
				{
					if (teamsFound.Find(i) == teamsFound.Size())
						continue;
					
					int curTeamFrags = GetTeamFrags(i);
					
					if (i == leaderIndex || curTeamFrags <= bottomFrags)
						continue;
					
					bottomFrags = curTeamFrags;
					bottomIndex = i;
					nameShown = teams[i].mName;
					barColor = teams[i].GetPlayerColor();
				}
			}
			else
			{
				for (int i = 0; i < players.Size(); i++)
				{
					if (i == leaderIndex)
						continue;
					if (!playerInGame[i])
						continue;
					if (players[i] == CPlayer)
						continue;
					if (!(players[i].mo is "DeltaPlayer"))
						continue;
					
					let deltaPly = DeltaPlayer(players[i].mo);
					int curPlyFrags = players[i].fragCount;
					
					if (curPlyFrags < bottomFrags)
						continue;
					
					bottomFrags = curPlyFrags;
					bottomIndex = i;
					nameShown = players[i].GetUserName();
					characterIcon = deltaPly.GetCharacterIconId();
					barColor = deltaPly.GetCharacterColor();
				}
			}
		}
		else
		{
			if (teamplay)
			{
				int teamIndex = CPlayer.GetTeam();
				nameShown = teams[CPlayer.GetTeam()].mName;
				barColor = teams[teamIndex].GetPlayerColor();
				bottomFrags = GetTeamFrags(teamIndex);
			}
			else
			{
				bottomFrags = CPlayer.fragCount;
				characterIcon = ply.GetCharacterIconId();
				barColor = ply.GetCharacterColor();
				nameShown = CPlayer.GetUserName();
			}
		}
		
		DrawTexture(_deathmatchCurrentPlayer, (108*_universalScale.x,
			-_vBorder - (leaderIsUs ? 38 : 6)*_universalScale.y),
			DI_SCREEN_CENTER_BOTTOM | DI_ITEM_LEFT_BOTTOM,
			scale: _universalScale*2);
		
		if (!characterIcon && (!teamplay || teamsFound.Size() == 1))
			return;
		
		barColor |= 0xff000000;
		nameShown.Truncate(16);
		Fill(barColor, -32*_universalScale.x, -_vBorder - 4*_universalScale.y,
			min(1., (max(0., bottomFrags) / max(1., fraglimit))) * 132 * _universalScale.x, -20 * _universalScale.y,
			DI_SCREEN_CENTER_BOTTOM);
		DrawTexture(characterIcon, (-33*_universalScale.x,
			-_vBorder - 4.5*_universalScale.y), DI_SCREEN_CENTER_BOTTOM
			| DI_ITEM_LEFT_BOTTOM, box: (25*_universalScale.x,
			20*_universalScale.y), scale: _universalScale);
		DrawString(_drHudFont, "" ..  bottomFrags, (98*_universalScale.x,
			-_vBorder - (fontHeight+11.5)*_universalScale.y),
			DI_SCREEN_CENTER_BOTTOM | DI_TEXT_ALIGN_RIGHT,
			scale: _universalScale*3);
		DrawString(_consoleFont, nameShown,
			((teamplay ? -33 : -12)*_universalScale.x, -_vBorder - (fontHeight+13.5)*_universalScale.y),
			DI_SCREEN_CENTER_BOTTOM | DI_TEXT_ALIGN_LEFT, scale: _universalScale/2);
	}
	
	protected void DrawMultiplayerHealth(DeltaPlayer ply, Vector2 pos)
	{
		double barWidth = _universalScale.x * 100,
		barHeight = _universalScale.y * 8;
		Color iconColor = ply.health > 0 ? 0xffffffff : 0x80ff4040;
		let userStr = ply.player.GetUserName();
		
		// this only works because _consoleFont is monospace
		int charWidth = _consoleFont.mFont.GetCharWidth("0") / 2;
		int panelW, panelH;
		[panelW, panelH] = TexMan.GetSize(_coopPanelBack);
		uint allowedLength = 19;
		
		if (ply.health <= 0)
			allowedLength -= 7;
		
		if (userStr.Length() > allowedLength)
		{
			userStr.Truncate(allowedLength);
			userStr = userStr .. "-";
		}
		
		if (ply.health <= 0)
			userStr = userStr .. " (DEAD)";
		
		DrawTexture(_coopPanelBack, (pos.X, pos.Y), DI_SCREEN_LEFT_TOP | DI_ITEM_LEFT_TOP, scale: _universalScale);
		DrawTexture(ply.GetCharacterIconID(), (pos.X, pos.Y) + _universalScale,
			DI_SCREEN_LEFT_TOP | DI_ITEM_LEFT_TOP, box: (25*_universalScale.x, 20*_universalScale.y),
			col: iconColor);
		DrawString(_consoleFont, userStr, (pos.X + 26*_universalScale.x, pos.Y + 2*_universalScale.y),
			scale: _universalScale/2);
		double healthPerc = DeltaMath.Clamp(float(ply.Health) / ply.GetMaxHealth(), 0, 2);
		Fill(ply.GetCharacterColor(), pos.X + (28.3*_universalScale.x), pos.Y + 13*_universalScale.y,
			barWidth * min(1, healthPerc), barHeight, DI_SCREEN_LEFT_TOP);
		Fill(ply.GetOverhealColor(), pos.X + (28.3*_universalScale.x), pos.Y + 13*_universalScale.y,
			barWidth * max(0, healthPerc - 1), barHeight, DI_SCREEN_LEFT_TOP);
		DrawString(_drHudFont, "" .. max(0, ply.Health), (pos.X + 126*_universalScale.x, pos.Y + 14.5*_universalScale.y),
			DI_SCREEN_LEFT_TOP | DI_TEXT_ALIGN_RIGHT, scale: _universalScale);
	}
	
	protected int GetTeamFrags(int teamIndex)
	{
		let frags = 0;
		
		for (int i = 0; i < players.Size(); i++)
		{
			if (!playerInGame[i])
				continue;
			if (players[i].GetTeam() != teamIndex)
				continue;
			
			frags += players[i].fragCount;
		}
		
		return frags;
	}
	
	protected float GetHealthPerc()
	{
		return CPlayer.mo.GetMaxHealth() == 0 ? 0 : min(2, CPlayer.Health / float(CPlayer.mo.GetMaxHealth()));
	}
	
	protected TextureID GetMainBindingIcon(string cmd)
	{
		int k = Bindings.GetKeysForCommand(cmd);
		
		// not a mouse button!
		if (k <= DELTA_CONTROLICON_TEXT || k >= DELTA_CONTROLICON_MAX)
			return null;
		
		return controlIcons.GetIfExists(k);
	}
	
	protected void DisplayBinding(string cmd, Vector2 pos, int flags, Vector2 scale)
	{
		let tex = GetMainBindingIcon(cmd);
		
		if (tex)
			DrawTexture(tex, pos, flags, scale: scale);
		else
		{
			int k = Bindings.GetKeysForCommand(cmd);
			string keys = Keybindings.NameKeys(k, 0);
			double newY = pos.y;
			
			if (flags & DI_ITEM_VCENTER)
				newY -= _consoleFont.mFont.GetHeight() / 2 * _universalScale.y;
			
			DrawString(_consoleFont, keys, (pos.x, newY), flags, scale: scale);
		}
	}
	
	protected void DrawLeftPanel(bool infiniteAmmo, double ticFrac)
	{
		double panelXSpacing = 4 * _universalScale.x;
		double panelYSpacing = 4 * _universalScale.y;
		double curY = -_vBorder;
		double barWidth = 144 * _universalScale.x;
		double barHeight = 16 * _universalScale.y;
		double labelXOffset = 50 * _universalScale.x;
		double barXOffset = 14 * _universalScale.x + labelXOffset + panelXSpacing;
		double panelY = curY;
		
		DrawTexture(_leftPanelBack, (_hBorder, panelY), DI_SCREEN_LEFT_BOTTOM | DI_ITEM_LEFT_BOTTOM, scale: _universalScale);
		
		double smallFontHeight = _drHudFont.mFont.GetGlyphHeight("0") * _universalScale.y;
		double halfDifference = (barHeight * _universalScale.y - smallFontHeight) / 2;
		double textYOffset = halfDifference + 0.5;
		
		DeltaPlayer ply = DeltaPlayer(CPlayer.mo);
		
		if (!ply)
			return;
		
		TextureID currentFace = GetMugshot(4, Mugshot.DISABLEOUCH | Mugshot.DISABLERAMPAGE);
		
		int temp, panelYSize, faceYSize;
		[temp, panelYSize] = TexMan.GetSize(_leftPanelBack);
		[temp, faceYSize] = TexMan.GetSize(currentFace);
		
		DrawTexture(currentFace, (_hBorder + panelXSpacing*2, panelY - panelYSize*_universalScale.y + 18*_universalScale.y),
			DI_SCREEN_LEFT_BOTTOM | DI_ITEM_LEFT_TOP, scale: _universalScale);
		
		curY -= 19*_universalScale.y;
		
		if (!deathmatch)
			DrawKeys(_hBorder + panelXSpacing + barXOffset, curY);
		
		/// ---- DRAWING TENSION POINTS ----
		// draw TP timer and bar
		curY -= 2*_universalScale.y + panelYSpacing;
		
		double tpTimer = float(ply.tensionDrainTimer) / ply.DRAIN_TIMER_START;
		Fill(0xffffffff, _hBorder + panelXSpacing + barXOffset, curY, tpTimer * barWidth, 3*_universalScale.y, DI_SCREEN_LEFT_BOTTOM);
		
		curY -= 3*_universalScale.y + barHeight;
		
		double tp = infiniteAmmo ? ply.maxTensionPoints : ply.tensionPoints;
		double maxTp = ply.maxTensionPoints;
		
		if (ply.ticLastGrazed >= 0)
		{
			int timePassed = level.Time - ply.ticLastGrazed;
			int alpha = 255 * (1 - (timePassed / 5.));
			
			DrawTexture(_tpHighlight, (_hBorder + panelXSpacing + labelXOffset - _universalScale.x, curY - _universalScale.y),
				DI_SCREEN_LEFT_BOTTOM | DI_ITEM_LEFT_TOP, scale: _universalScale,
				col: Color(alpha, 255, 255, 255));
		}
		
		Fill(Color(255, 255, 0, 0), _hBorder + panelXSpacing + barXOffset, curY,
			DeltaMath.Lerp(_oldTp, _tpInterp.GetValue(), ticFrac) / maxTp * barWidth,
			barHeight, DI_SCREEN_LEFT_BOTTOM);
		Fill(Color(255, 255, 160, 64), _hBorder + panelXSpacing + barXOffset, curY,
			tp / maxTp * barWidth, barHeight, DI_SCREEN_LEFT_BOTTOM);
		
		if (tp >= 1 && tp <= maxTp - 1)
			Fill(Color(255, 255, 255, 255), _hBorder + panelXSpacing + barXOffset + barWidth * (tp / maxTp) - _universalScale.x, curY, _universalScale.x, barHeight, DI_SCREEN_LEFT_BOTTOM);
		
		// draw TP text
		if (!infiniteAmmo)
		{
			if (tp < maxTp)
				DrawString(_drHudFont, String.Format("%d", tp * 100 / maxTp),
					(_hBorder + barWidth + barXOffset + _universalScale.x, curY + textYOffset/2 + _universalScale.y),
					DI_SCREEN_LEFT_BOTTOM | DI_TEXT_ALIGN_RIGHT,
					scale: _universalScale * 2);
			else
				DrawTexture(_tpMaxText,
					(_hBorder + barWidth + barXOffset, curY + textYOffset/2 + _universalScale.y),
					DI_SCREEN_LEFT_BOTTOM | DI_ITEM_RIGHT_TOP, scale: _universalScale * 2);
		}
		else
			DrawTexture(_infiniteText,
				(_hBorder + barWidth + barXOffset + _universalScale.x, curY + panelYSpacing + barHeight/2 + _universalScale.y),
				DI_SCREEN_LEFT_BOTTOM | DI_ITEM_RIGHT, scale: _universalScale * 1.25);
		
		// ================
		//  DRAWING HEALTH
		// ================
		curY -= panelYSpacing + barHeight;
		Fill(ply.GetCharacterColor(), _hBorder + panelXSpacing + barXOffset,
			curY, min(1, GetHealthPerc()) * barWidth, barHeight, DI_SCREEN_LEFT_BOTTOM);
		
		if (GetHealthPerc() > 1)
			Fill(ply.GetOverhealColor(), _hBorder + panelXSpacing + barXOffset,
				curY, min(1, GetHealthPerc() - 1) * barWidth, barHeight, DI_SCREEN_LEFT_BOTTOM);
		
		string format = GetHealthPerc() <= 0.33 ? "\c[DeltaLowHealth]%s" : "%s";
		string maxHp = String.Format(format, "" .. ply.GetMaxHealth());
		int maxHpWidth = _drHudFont.mFont.StringWidth(maxHp) * _universalScale.x;
		int slashWidth = _drHudFont.mFont.GetCharWidth("/") * _universalScale.x;
		DrawString(_drHudFont, String.Format(format, "" .. CPlayer.Health),
			(_hBorder + barWidth + barXOffset - maxHpWidth - (2*slashWidth), curY + textYOffset/2 + _universalScale.y),
			DI_SCREEN_LEFT_BOTTOM | DI_TEXT_ALIGN_RIGHT, scale: _universalScale * 2);
		DrawString(_drHudFont, String.Format(format, "/"),
			(_hBorder + barWidth + barXOffset - maxHpWidth - slashWidth, curY + textYOffset/2 + _universalScale.y),
			DI_SCREEN_LEFT_BOTTOM | DI_TEXT_ALIGN_RIGHT, scale: _universalScale);
		DrawString(_drHudFont, maxHp,
			(_hBorder + barWidth + barXOffset + _universalScale.x, curY + textYOffset/2 + _universalScale.y),
			DI_SCREEN_LEFT_BOTTOM | DI_TEXT_ALIGN_RIGHT, scale: _universalScale * 2);
		DrawTexture(_hpText,
			(_hBorder + labelXOffset + panelXSpacing, curY + panelYSpacing + barHeight/2),
			DI_SCREEN_LEFT_BOTTOM | DI_ITEM_LEFT, scale: (_universalScale.x, _universalScale.y),
			col: GetHealthPerc() <= 0.33 ? 0xffffff00 : 0xffffffff);
		
		// =============================
		//  DRAWING OFFHAND INFORMATION
		// =============================
		double offhandPanelHeight = 36 * _universalScale.y;
		bool canUse = ply.CanUseOffhand();
		curY -= offhandPanelHeight + panelYSpacing*2;
		Fill(0x80000000, _hBorder, curY, panelXSpacing*3 + 48*_universalScale.x, offhandPanelHeight);
		// control icons should all be 16px x 16px (or equivalent if scaled)
		DisplayBinding("+offhand", (_hBorder + panelXSpacing, curY + offhandPanelHeight/2),
			DI_SCREEN_LEFT_BOTTOM | DI_ITEM_LEFT | DI_ITEM_VCENTER, _universalScale);
		// offhand icons should all be 32px x 32px (or equivalent if scaled)
		DrawTexture(ply.GetOffhandIconID(), (_hBorder + panelXSpacing*2 + 16*_universalScale.x, curY + 2*_universalScale.y),
			DI_SCREEN_LEFT_BOTTOM | DI_ITEM_LEFT_TOP, scale: _universalScale,
			col: canUse ? (ply.GetIsUsingOffhand() ? Color(255, 255, 160, 64) : 0xffffffff) : 0x80606060);
	}
	
	protected void DrawRightPanel(bool infiniteAmmo)
	{
		if (!ammos.Size())
			return;
		
		double widgetWidth = 70 * _universalScale.x,
			hPerAmmo = 22 * _universalScale.y,
			h = ammos.Size() * hPerAmmo + (5*_universalScale.y);
		Fill(Color(128, 0, 0, 0), -_hBorder - widgetWidth, -_vBorder - h,
			widgetWidth, h, DI_SCREEN_RIGHT_BOTTOM);
		
		for (int i = 0; i < ammos.Size(); i++)
		{
			let am = ammos[ammos.Size() - 1 - i];
			let amCount = CPlayer.mo.CountInv(am);
			let ammoIcon = ammoIcons.GetIfExists(am.GetClassName());
			double curAlpha = (CPlayer.ReadyWeapon ? (am == CPlayer.ReadyWeapon.AmmoType1) : false) ? 1 : 0.2;
			
			DrawTexture(ammoIcon, (-_hBorder - widgetWidth + 5*_universalScale.x,
				-_vBorder - 5*_universalScale.y - hPerAmmo*i),
				DI_ITEM_LEFT_BOTTOM | DI_SCREEN_RIGHT_BOTTOM,
				alpha: curAlpha,
				box: _universalScale * 16, scale: _universalScale);
			DrawString(_drHudFont, "" .. amCount,
				(-_hBorder - (5*_universalScale.x), -_vBorder - (i+1)*(hPerAmmo) + 1*_universalScale.y),
				DI_SCREEN_RIGHT_BOTTOM | DI_TEXT_ALIGN_RIGHT,
				alpha: curAlpha,
				scale: _universalScale*3);
		}
	}
	
	protected void DrawAllAmmo(double x, double y, double w, double hPerAmmo)
	{
		
	}
	
	protected void DrawKeys(double x, double y)
	{
		int count = Key.GetKeyTypeCount();
		double newX = x;
		Key inv;
		
		for (int i = 0; i <= count - 1; i++)
		{
			if (inv = Key(CPlayer.mo.FindInventory(Key.GetKeyType(i))))
			{
				TextureID icon;
				
				if (inv.SpawnState && inv.SpawnState.sprite != 0)
				{
					let state = inv.SpawnState;
					
					if (state != null)
						icon = state.GetSpriteTexture(0);
					else
						icon.SetNull();
				}
				
				if (icon.IsNull())
					icon = inv.Icon;
				
				if (icon.IsValid())
				{
					DrawTexture(icon, (newX, y), DI_SCREEN_LEFT_BOTTOM
						| DI_ITEM_LEFT_TOP, box: 16 * _universalScale, scale: _universalScale);
					newX += 18*_universalScale.x;
				}
			}
		}
	}
	
	protected void DrawReticle()
	{
		if (CPlayer.cheats & CF_CHASECAM || automapActive
			|| !(CPlayer.mo is "DeltaPlayer") || !cl_delta_showCrosshair)
			return;
		
		DeltaPlayer ply = DeltaPlayer(CPlayer.mo);
		if (ply.GetIsUsingOffhand())
			return;
		
		let crosshair = _defaultCrosshair,
			weap = DeltaWeapon(CPlayer.ReadyWeapon),
			xhairState = ply.GetCrosshairState();
		
		if (weap)
			crosshair = weap.GetCrosshair();
		
		Color xhairColor = xhairState == DELTA_XHR_NEUTRAL ? cl_delta_crosshairColor :
			(xhairState == DELTA_XHR_FRIENDLY ? cl_delta_crosshairFriendlyColor : cl_delta_crosshairEnemyColor);
		xhairColor |= 0xff000000;
		DrawTexture(crosshair, (0, 0), DI_SCREEN_CENTER | DI_ITEM_CENTER, scale: _universalScale * 0.5, col: xhairColor);
		
		if (!ply.CanUseOffhand())
			return;
		
		DrawTexture(_offhandCrosshair, (0, 0), DI_SCREEN_CENTER | DI_ITEM_CENTER,
			scale: _universalScale * 0.5, col: Color(255, 255, 160, 64));
	}
	
	protected void DrawDeathStuff()
	{
		DeltaPlayer ply = DeltaPlayer(CPlayer.mo);
		if (!ply)
			return;
		
		int reminderTimer = ply.GetDeathTimer() - TICRATE * 10;
		double textSpeed = 1/2.;
		
		if (multiplayer && !deathmatch) // we can respawn whenever in deathmatch
			return;
		if (reminderTimer < 0)
			return;
		
		String respawnReminder = StringTable.Localize("$TXT_DELTA_RESPAWNMSG1"),
			reminderThisFrame = respawnReminder;
		reminderThisFrame.Truncate(reminderTimer * textSpeed);
		
		int xOffset = -_consoleFont.mFont.StringWidth(respawnReminder) / 2 * _universalScale.x;
		int yOffset = -50 * _universalScale.y;
		DrawString(_consoleFont, reminderThisFrame, (xOffset, yOffset),
			DI_SCREEN_CENTER, scale: _universalScale);
		
		reminderTimer -= respawnReminder.Length() / textSpeed + (TICRATE/2);
		if (reminderTimer < 0)
			return;
		
		respawnReminder = StringTable.Localize("$TXT_DELTA_RESPAWNMSG2");
		reminderThisFrame = respawnReminder;
		reminderThisFrame.Truncate(reminderTimer * textSpeed);
		xOffset = -_consoleFont.mFont.StringWidth(respawnReminder) / 2 * _universalScale.x;
		yOffset += _consoleFont.mFont.GetHeight() * _universalScale.y * 2;
		
		DrawString(_consoleFont, reminderThisFrame, (xOffset, yOffset),
			DI_SCREEN_CENTER, scale: _universalScale);
		
		reminderTimer -= respawnReminder.Length() / textSpeed + (TICRATE);
		if (reminderTimer < 0)
			return;
		
		int useBind, useless;
		[useBind, useless] = Bindings.GetKeysForCommand("+use");
		String keyNames = KeyBindings.NameKeys(useBind, 0);
		keyNames.ToUpper();
		
		string targetFormat = (deathmatch || (dmflags2 & LEVEL2_ALLOWRESPAWN) || sv_singleplayerrespawn
		|| G_SkillPropertyInt(SKILLP_PlayerRespawn))
			? "$TXT_DELTA_RESPAWNREMINDDM" : "$TXT_DELTA_RESPAWNREMIND";
		respawnReminder = String.Format(StringTable.Localize(targetFormat), keyNames);
		reminderThisFrame = respawnReminder;
		reminderThisFrame.Truncate(reminderTimer * textSpeed);
		xOffset = -_consoleFont.mFont.StringWidth(respawnReminder) / 2 * _universalScale.x;
		yOffset += _consoleFont.mFont.GetHeight() * _universalScale.y * 3;
		
		DrawString(_consoleFont, reminderThisFrame, (xOffset, yOffset),
			DI_SCREEN_CENTER, scale: _universalScale);
	}
	
	void CreateDamageIndicator(Actor source)
	{
		if (!source)
			return;
		
		int smallestTimer = -1;
		int smallestTimerIndex;
		
		for (int i = 0; i < grazeIndicators.Size(); i++)
		{
			let grz = grazeIndicators[i].grazing;
			if (!grz || !grz.target || (grz.target.bMissile && grz.target != source))
				continue;
			
			grazeIndicators[i].timer = 0;
		}
		
		for (int i = 0; i < damageIndicators.Size(); i++)
		{
			if (damageIndicators[i].timer <= 0)
			{
				damageIndicators[i].timer = DAMAGE_INDICATOR_TIME;
				damageIndicators[i].sourcePos = source.Pos;
				return;
			}
			
			if (smallestTimer > 0 && damageIndicators[i].timer > smallestTimer)
				continue;
			
			smallestTimer = damageIndicators[i].timer;
			smallestTimerIndex = i;
		}
		
		damageIndicators[smallestTimerIndex].timer = DAMAGE_INDICATOR_TIME;
		damageIndicators[smallestTimerIndex].sourcePos = source.Pos;
	}
	
	void CreateGrazeIndicator(Actor source)
	{
		if (!source)
			return;
		
		int smallestTimer = -1;
		int smallestTimerIndex;
		
		for (int i = 0; i < grazeIndicators.Size(); i++)
		{
			if (grazeIndicators[i].timer <= 0 || !grazeIndicators[i].grazing
				|| grazeIndicators[i].grazing == source)
			{
				grazeIndicators[i].timer = GRAZE_INDICATOR_TIME;
				grazeIndicators[i].grazing = source;
				grazeIndicators[i].sourcePos = source.Pos;
				return;
			}
			
			if (smallestTimer > 0 && grazeIndicators[i].timer > smallestTimer)
				continue;
			
			smallestTimer = grazeIndicators[i].timer;
			smallestTimerIndex = i;
		}
		
		grazeIndicators[smallestTimerIndex].timer = GRAZE_INDICATOR_TIME;
		grazeIndicators[smallestTimerIndex].grazing = source;
		grazeIndicators[smallestTimerIndex].sourcePos = source.Pos;
	}
}

class DeltaAltHUD : AltHUD
{
	override void DrawInGame(PlayerInfo CPlayer)
	{
		// kept blank so we don't draw an alt hud at all
	}
}